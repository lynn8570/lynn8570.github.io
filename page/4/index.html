<!DOCTYPE html>
<html lang>
  <head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="android"><meta name="keywords" content="android"><link rel="alternate" href="/default" title="Lynn8570's Blog"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0">
<link rel="canonical" href="https://lynn8570.github.io/page/4/">

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css"><link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css">
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0">

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":true,"latex":false};
</script>

    <title>Lynn8570's Blog</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Lynn8570's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Lynn8570's Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><section id="posts" class="posts"><article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2015/12/11/customer framework jar/">自定义framework动态链接库jar</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2015-12-11
        </span><span class="post-category">
            <a href="/categories/ANDROID/">ANDROID</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇总结的是自定义framework资源包的打包和访问，而这一篇，相对要简单一些，是android平台的自定义动态链接库。目的在于定义一个framework级别的jar，供相关应用使用。之前一个项目的common组件采用的是BUILD_STATIC_JAVA_LIBRARY方式，调试起来相对简单，不需要涉及到framework的资源，framework的jar包这样，但是会造成每个应用内都引入一个common的jar包，各自为营，不知不觉加大了整体软件的大小。因此这种common级别的jar包，还是作成动态jar，加入到系统中。</p>
<h1 id="common-library"><a href="#common-library" class="headerlink" title="common library"></a>common library</h1><p>其实参考android的sample代码就可以完成基本的jar包编译，这里只是记录一下，其实，没那么难，啦啦。jar库的基文件目录如下：</p>
<p><img src="http://7xl98n.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20151216094557.jpg" alt></p>
<p>java下存放纯java代码，一些需要的资源，我们就直接使用上一篇中说的自定义framework资源。</p>
<h2 id="jar包的com-zowee-widget-xml"><a href="#jar包的com-zowee-widget-xml" class="headerlink" title="jar包的com.zowee.widget.xml"></a>jar包的com.zowee.widget.xml</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;permissions&gt;
    &lt;library name=&quot;com.zowee.widget&quot;
            file=&quot;/system/framework/com.zowee.widget.jar&quot;/&gt;
&lt;/permissions&gt;</code></pre><h2 id="项目编译的mk"><a href="#项目编译的mk" class="headerlink" title="项目编译的mk"></a>项目编译的mk</h2><p> 项目编译的mk代码如下</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">ifneq ($(TARGET_BUILD_JAVA_SUPPORT_LEVEL),)</span><br><span class="line"># This makefile shows how to build your own shared library that can be</span><br><span class="line"># shipped on the system of a phone, and included additional examples of</span><br><span class="line"># including JNI code with the library and writing client applications against it.</span><br><span class="line">LOCAL_PATH := $(call my-dir)</span><br><span class="line"># the library</span><br><span class="line"># ============================================================</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_SRC_FILES := \</span><br><span class="line">        $(call all-subdir-java-files)</span><br><span class="line">LOCAL_MODULE_TAGS := optional</span><br><span class="line"></span><br><span class="line"># 我们要编译的库名就是com.zowee.widget.jar</span><br><span class="line">LOCAL_MODULE:= com.zowee.widget</span><br><span class="line">include $(BUILD_JAVA_LIBRARY)</span><br><span class="line"># 下面我们需要将com.zowee.widget.xml编译会生出到</span><br><span class="line"># system/etc/permission下，用于作权限声明的</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_MODULE := com.zowee.widget.xml</span><br><span class="line">LOCAL_MODULE_TAGS := optional</span><br><span class="line">LOCAL_MODULE_CLASS :=ETC</span><br><span class="line">LOCAL_MODULE_PATH :=$(TARGET_OUT_ETC)/permissions</span><br><span class="line">LOCAL_SRC_FILES :=$(LOCAL_MODULE)</span><br><span class="line">include $(BUILD_PREBUILT)</span><br><span class="line"></span><br><span class="line"># the documentation</span><br><span class="line"># ============================================================</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_SRC_FILES := $(call all-subdir-java-files) $(call all-subdir-html-files)</span><br><span class="line">LOCAL_MODULE:= com.zowee.widget</span><br><span class="line">LOCAL_DROIDDOC_OPTIONS := com.zowee.widget</span><br><span class="line">LOCAL_MODULE_CLASS := JAVA_LIBRARIES</span><br><span class="line">LOCAL_DROIDDOC_USE_STANDARD_DOCLET := true</span><br><span class="line">include $(BUILD_DROIDDOC)</span><br><span class="line"># The JNI component</span><br><span class="line"># ============================================================</span><br><span class="line"># Also build all of the sub-targets under this one: the library&apos;s</span><br><span class="line"># associated JNI code, and a sample client of the library.</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">include $(call all-makefiles-under,$(LOCAL_PATH))</span><br><span class="line">endif # JAVA_SUPPORT</span><br></pre></td></tr></table></figure></code></pre><p>以上大部分为参考sample代码，编译之后，会生成 </p>
<p><code>Install:out/target/product/.../system/framework/com.zowee.widget.jar</code><br>和
 <code>Copy xml: out/target/product/.../system/etc/permissions/com.zowee.widget.xml</code>;</p>
<h2 id="修改device-mk文件"><a href="#修改device-mk文件" class="headerlink" title="修改device.mk文件"></a>修改device.mk文件</h2><p>将这两个添加到项目编译中，这样生成的system.image才会包含所需要的jar和xml文件；<br>拷贝xml文件：<br><code>PRODUCT_COPY_FILES += vendor/zowee/proprietary/framework/WidgetLibrary/com.zowee.widget.xml:system/etc/permissions/com.zowee.widget.xml</code><br>添加jar模块：<code>PRODUCT_PACKAGES+=com.zowee.widget</code></p>
<h1 id="app如何访问引入动态链接库"><a href="#app如何访问引入动态链接库" class="headerlink" title="app如何访问引入动态链接库"></a>app如何访问引入动态链接库</h1><p>作为一个普通的app，如何访问系统的framework res资源，如何引入动态的jar包，并在xml和java代码中访问公共资源中的内容.</p>
<h2 id="app的mk文件"><a href="#app的mk文件" class="headerlink" title="app的mk文件"></a>app的mk文件</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH:= $(call my-dir)</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_MODULE_TAGS := optional</span><br><span class="line"></span><br><span class="line"># 要编译的app模块名称PlatformLibraryClient.apk</span><br><span class="line">LOCAL_PACKAGE_NAME := PlatformLibraryClient</span><br><span class="line"># Only compile source java files in this apk.</span><br><span class="line">LOCAL_SRC_FILES := $(call all-java-files-under, src)</span><br><span class="line"># 不要用current！，不然无法访问到自定义的framework组件</span><br><span class="line">#LOCAL_SDK_VERSION := current</span><br><span class="line"># 将动态库导入编译</span><br><span class="line">LOCAL_JAVA_LIBRARIES := com.zowee.widget</span><br><span class="line">LOCAL_PROGUARD_ENABLED := disabled</span><br><span class="line">include $(BUILD_PACKAGE)</span><br></pre></td></tr></table></figure></code></pre><h2 id="AndroidManifest-xml文件"><a href="#AndroidManifest-xml文件" class="headerlink" title="AndroidManifest.xml文件"></a>AndroidManifest.xml文件</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    package=&quot;com.example.android.platform_library.client&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;application android:label=&quot;Platform Lib Client&quot;&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;!--将 com.zowee.widget 引入--&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;uses-library android:name=&quot;com.zowee.widget&quot; /&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;activity android:name=&quot;Client&quot;&gt;</span><br><span class="line">            &lt;intent-filter&gt;</span><br><span class="line">                &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;</span><br><span class="line">                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;</span><br><span class="line">            &lt;/intent-filter&gt;</span><br><span class="line">        &lt;/activity&gt;</span><br><span class="line">    &lt;/application&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure></code></pre><h1 id="app如何访问自定义framework资源"><a href="#app如何访问自定义framework资源" class="headerlink" title="app如何访问自定义framework资源"></a>app如何访问自定义framework资源</h1><h2 id="java代码中"><a href="#java代码中" class="headerlink" title="java代码中"></a>java代码中</h2><p>只要导入编译正常，基本上java代码中就可以直接对自定义framework的资源进行访问，例如：<br>对jar包中的自定义控件，自定义资源的访问</p>
<p><code>import com.zowee.widget.ToolbarImageTextButton;</code></p>
<p><code>b2.setText(getString(com.zowee.R.string.zowee),1);</code></p>
<h2 id="xml中自定义控件的访问"><a href="#xml中自定义控件的访问" class="headerlink" title="xml中自定义控件的访问"></a>xml中自定义控件的访问</h2><p>xml中对自定义控件的访问，自定义属性的访问，自定义资源的访问，可参考如下：</p>
<pre><code>&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    xmlns:zowee=&quot;http://schemas.android.com/apk/res/com.zowee&quot; 
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    &gt;
    &lt;com.zowee.widget.ToolbarImageTextButton
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:text=&quot;@com.zowee:string/zowee&quot;
    zowee:bracketColor=&quot;#057852dd&quot; 
    android:id=&quot;@+id/toolbutton&quot;
    /&gt;
&lt;/RelativeLayout&gt;</code></pre><p>请注意 <code>xmlns:zowee=&quot;http://schemas.android.com/apk/res/com.zowee&quot;</code> 和 <code>zowee:bracketColor=&quot;#057852dd&quot;</code><br>以及<br><code>android:text=&quot;@com.zowee:string/zowee&quot;</code></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>自此，针对自定义的一套资源和jar的框架已经完成了，这样做的目的是，当整个平台升级的时候，我们可以单独将自定义的framework res 和 framework jar 先进行移植，接着依赖于这些的自定义app,也可以顺利的在新的平台上运行了</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2015/12/10/customer framework resource/">自定义framework资源apk</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2015-12-10
        </span><span class="post-category">
            <a href="/categories/ANDROID/">ANDROID</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>去年在高通平台上的加过一次这种自定义framework级别的资源包，今年在MTK平台又部署了一次，当然第二次就比较轻车熟路了；趁现在编译时间，把这次的部署，完整记录一下吧。</p>
<h1 id="自定义framework资源的-packing-amp-accessing"><a href="#自定义framework资源的-packing-amp-accessing" class="headerlink" title="自定义framework资源的 packing&amp;accessing"></a>自定义framework资源的 packing&amp;accessing</h1><p>首先，我们先明确这么做的目的是，将公司自定义的一些图片文字样式等资源独立与平台；这样可以与平台代码区分；这么做的好处就是，方便以后每个os的升级，在移植上的工作量相对减少。以下为具体的操作步骤：</p>
<ol>
<li><p>建立自定义资源目录结构<br>  在vendor目录下，建立一个与framework res类似路径的资源文件夹’vendor\zowee\proprietary\framework\base\res’；目录结构如下图</p>
<p> <img src="http://7xl98n.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20151210141422.jpg" alt></p>
</li>
<li><p>编写Android.mk文件，模块名称<code>LOCAL_PACKAGE_NAME := zowee-res</code>，资源flag 3~9可用<code>LOCAL_AAPT_FLAGS := -x3</code>；<code>LOCAL_NO_ZOWEE := true</code></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := $(call my-dir)</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"># include apicheck.mk later, we need the build pass to prepare the first version</span><br><span class="line"># include $(LOCAL_PATH)/apicheck.mk</span><br><span class="line">LOCAL_PACKAGE_NAME := zowee-res</span><br><span class="line">LOCAL_CERTIFICATE := platform</span><br><span class="line">LOCAL_AAPT_FLAGS := -x3</span><br><span class="line"></span><br><span class="line"># Tell aapt to build resource in utf16(the ROM will be enlarged),</span><br><span class="line"># in order to save RAM size for string cache table</span><br><span class="line">ifeq (yes,strip$(MTK_GMO_RAM_OPTIMIZE))</span><br><span class="line">LOCAL_AAPT_FLAGS += --utf16</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">#LOCAL_NO_MTKRES := true</span><br><span class="line">LOCAL_NO_ZOWEE := true</span><br><span class="line">LOCAL_MODULE_TAGS := optional</span><br><span class="line"># Install this alongside the libraries.</span><br><span class="line">LOCAL_MODULE_PATH := $(TARGET_OUT_JAVA_LIBRARIES)</span><br><span class="line"># Create package-export.apk, which other packages can use to get</span><br><span class="line"># PRODUCT-agnostic resource data like IDs and type definitions.</span><br><span class="line">LOCAL_EXPORT_PACKAGE_RESOURCES := true	</span><br><span class="line">include $(BUILD_PACKAGE)</span><br><span class="line"></span><br><span class="line"># define a global intermediate target that other module may depend on.</span><br><span class="line">.PHONY: zowee-res-package-target</span><br><span class="line">zowee-res-package-target: $(LOCAL_BUILT_MODULE)</span><br></pre></td></tr></table></figure>
</li>
<li><p>AndroidManifest.xml文件，代码可参考：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    package=&quot;com.zowee&quot; android:sharedUserId=&quot;android.uid.system&quot;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改\device\mediatek\common下device.mk，将新的资源模块添加到system img中</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># for mediatek-res</span><br><span class="line">PRODUCT_PACKAGES += mediatek-res</span><br><span class="line">	</span><br><span class="line"># for zowee-ress</span><br><span class="line">PRODUCT_PACKAGES += zowee-res</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改Z:\MT5505\alps\frameworks\base\libs\androidfw下的Assetmanager.cpp，将新的资源模块添加的默认的assets路径中</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">///M:add the resource path</span><br><span class="line">static const char* kMediatekAssets = &quot;framework/mediatek-res/mediatek-res.apk&quot;;</span><br><span class="line">static const char* kZoweeAssets = &quot;framework/zowee-res/zowee-res.apk&quot;;</span><br><span class="line">....</span><br><span class="line"> ///M:add the new resource path into default path,so all the app can reference,@&#123;	</span><br><span class="line">bool isOK1 =addAssetPath(path, NULL);</span><br><span class="line">String8 path2(root);</span><br><span class="line">path2.appendPath(kMediatekAssets);</span><br><span class="line">bool isOK2 =addAssetPath(path2, NULL);</span><br><span class="line">if(!isOK2)&#123;</span><br><span class="line">  ALOGW(&quot;AssetManager--&gt;addDefaultAssets isok2 is false&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String8 path3(root);</span><br><span class="line">path3.appendPath(kZoweeAssets);</span><br><span class="line">bool isOK3 =addAssetPath(path3, NULL);</span><br><span class="line">if(!isOK3)&#123;</span><br><span class="line">  ALOGW(&quot;AssetManager--&gt;addDefaultAssets isok3 is false&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">	 ALOGW(&quot;AssetManager--&gt;addDefaultAssets isok3 is true&quot;);</span><br><span class="line">&#125;</span><br><span class="line">return isOK1;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改alps\build\core下的package_internal.mk，添加编译依赖关系等</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">resource_export_package := $(intermediates.COMMON)/package-export.apk</span><br><span class="line">$(R_file_stamp): $(resource_export_package)</span><br><span class="line">$(call intermediates-dir-for,APPS,mediatek-res,,COMMON)/package-export.apk:$(call intermediates-dir-for,APPS,framework-res,,COMMON)/src/R.stamp</span><br><span class="line">$(call intermediates-dir-for,APPS,zowee-res,,COMMON)/package-export.apk:$(call intermediates-dir-for,APPS,mediatek-res,,COMMON)/src/R.stamp</span><br><span class="line">........</span><br><span class="line">mediatek_res_package_export :=</span><br><span class="line">mediatek_res_package_export_deps :=</span><br><span class="line">  ifneq ($(LOCAL_NO_MTKRES), true)</span><br><span class="line">    mediatek_res_package_export += \</span><br><span class="line">      $(call intermediates-dir-for,APPS,mediatek-res,,COMMON)/package-export.apk</span><br><span class="line">      mediatek_res_package_export_deps += \</span><br><span class="line">      $(call intermediates-dir-for,APPS,mediatek-res,,COMMON)/src/R.stamp</span><br><span class="line">      </span><br><span class="line">      ifneq ($(LOCAL_NO_ZOWEE), true)</span><br><span class="line">       mediatek_res_package_export += \</span><br><span class="line">          $(call intermediates-dir-for,APPS,zowee-res,,COMMON)/package-export.apk</span><br><span class="line">       mediatek_res_package_export_deps += \</span><br><span class="line">          $(call intermediates-dir-for,APPS,zowee-res,,COMMON)/src/R.stamp</span><br><span class="line">      endif</span><br><span class="line">  endif</span><br><span class="line">......</span><br><span class="line">$(filter-out $(mediatek_res_package_export),$(resource_export_package)): $(mediatek_res_package_export_deps)</span><br><span class="line">$(R_file_stamp): $(mediatek_res_package_export_deps)</span><br><span class="line">$(resource_export_package) $(R_file_stamp) $(LOCAL_BUILT_MODULE): $(all_library_res_package_export_deps)</span><br><span class="line">$(LOCAL_INTERMEDIATE_TARGETS): \</span><br><span class="line">    PRIVATE_AAPT_INCLUDES := $(all_library_res_package_exports) $(mediatek_res_package_export)</span><br><span class="line">endif # LOCAL_NO_STANDARD_LIBRARIES</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改alps\frameworks\base下Android.mk将资源路径添加的编译路径中</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">framework_res_source_path := APPS/framework-res_intermediates/src</span><br><span class="line"># M:add mediatek resource path</span><br><span class="line">mediatek-res-source-path := APPS/mediatek-res_intermediates/src</span><br><span class="line">zowee-res-source-path := APPS/zowee-res_intermediates/src</span><br><span class="line">.......</span><br><span class="line">LOCAL_INTERMEDIATE_SOURCES += \</span><br><span class="line">      $(zowee-res-source-path)/com/zowee/R.java \</span><br><span class="line">      $(zowee-res-source-path)/com/zowee/Manifest.java \</span><br><span class="line">      $(zowee-res-source-path)/com/zowee/internal/R.java \</span><br><span class="line">			$(mediatek-res-source-path)/com/mediatek/internal/R.java \</span><br><span class="line">			$(mediatek-res-source-path)/com/mediatek/R.java \</span><br><span class="line">			$(mediatek-res-source-path)/com/mediatek/Manifest.java </span><br><span class="line"># @&#125;</span><br><span class="line">......</span><br><span class="line">zowee_res_R_stamp := \</span><br><span class="line">	$(call intermediates-dir-for,APPS,zowee-res,,COMMON)/src/R.stamp</span><br><span class="line">$(full_classes_compiled_jar): $(zowee_res_R_stamp)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Z:\MT5505\alps\build\core clear_vars.mk添加<code>LOCAL_NO_ZOWEE :=</code></p>
</li>
<li><p>修改alps\frameworks\base\services\core\java\com\android\server\pm<br>PackageManagerService.java，不对新的资源apk进行 dexopted</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">alreadyDexOpted.add(frameworkDir.getPath() + &quot;/framework-res.apk&quot;);</span><br><span class="line"></span><br><span class="line">/// M: This file doesn&apos;t contain any code,just like framework-res,so don&apos;t dexopt it</span><br><span class="line">alreadyDexOpted.add(frameworkDir.getPath() + &quot;/mediatek-res/mediatek-res.apk&quot;);</span><br><span class="line">alreadyDexOpted.add(frameworkDir.getPath() + &quot;/zowee-res/zowee-res.apk&quot;);</span><br><span class="line"></span><br><span class="line">/** M: [CIP] Add CIP scanning path variable @&#123; */</span><br><span class="line">File customFrameworkDir = new File(&quot;/custom/framework&quot;);</span><br><span class="line">/// M: [CIP] Add custom resources to libFiles to avoid dex opt.</span><br><span class="line">alreadyDexOpted.add(customFrameworkDir.getPath() + &quot;/framework-res.apk&quot;);</span><br><span class="line">alreadyDexOpted.add(customFrameworkDir.getPath() + &quot;/mediatek-res.apk&quot;);</span><br><span class="line">alreadyDexOpted.add(customFrameworkDir.getPath() + &quot;/zowee-res.apk&quot;);</span><br><span class="line">/** @&#125; */</span><br></pre></td></tr></table></figure>
</li>
<li><p>针对L版本，还需要修个alps\frameworks\base\libs\androidfw    for L 版本<br><code>ResourceTypes.cpp</code> 主要是对资源id的查找映射表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#define APP_PACKAGE_ID      0x7f</span><br><span class="line">#define SYS_MTK_PACKAGE_ID  0x08 /// M: 0x08 is mediatek-res.apk resource ID</span><br><span class="line">#define SYS_ZOWEE_PACKAGE_ID  0x03 /// M: 0x03 is zowee-res.apk resource ID</span><br><span class="line">#define SYS_PACKAGE_ID      0x01</span><br><span class="line">.......</span><br><span class="line"> if (packageId != APP_PACKAGE_ID &amp;&amp; packageId != SYS_PACKAGE_ID &amp;&amp; packageId != SYS_MTK_PACKAGE_ID</span><br><span class="line">                	&amp;&amp; packageId != SYS_ZOWEE_PACKAGE_ID) &#123;</span><br><span class="line">                    outValue-&gt;dataType = Res_value::TYPE_DYNAMIC_REFERENCE;</span><br><span class="line">                &#125;</span><br><span class="line">......</span><br><span class="line">else if (packageId == APP_PACKAGE_ID || packageId == SYS_PACKAGE_ID || packageId == SYS_MTK_PACKAGE_ID</span><br><span class="line">                    	|| packageId == SYS_ZOWEE_PACKAGE_ID) &#123;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">mLookupTable[APP_PACKAGE_ID] = APP_PACKAGE_ID;</span><br><span class="line">    mLookupTable[SYS_PACKAGE_ID] = SYS_PACKAGE_ID;</span><br><span class="line">    mLookupTable[SYS_ZOWEE_PACKAGE_ID] = SYS_ZOWEE_PACKAGE_ID;</span><br><span class="line">    mLookupTable[SYS_MTK_PACKAGE_ID] = SYS_MTK_PACKAGE_ID;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="自定义资源的添加和访问"><a href="#自定义资源的添加和访问" class="headerlink" title="自定义资源的添加和访问"></a>自定义资源的添加和访问</h1><ol>
<li>在自定义资源目录下，像普通的应用一样，添加<code>values/strings.xml</code>等字符串，颜色等资源，编译之后，在out目录下的APPS intermediate文件中，将生成的<code>public_resource.xml</code>文件中，需要开放权限，作为外部访问的添加到资源目录下的<code>values/public.xml</code>中</li>
</ol>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">  &lt;!-- Declared at vendor/zowee/proprietary/framework/base/res/res/values/strings.xml:23 --&gt;</span><br><span class="line">  &lt;public type=&quot;string&quot; name=&quot;zowee&quot; id=&quot;0x03020000&quot; /&gt;</span><br><span class="line">  &lt;!-- Declared at vendor/zowee/proprietary/framework/base/res/res/values/attrs.xml:5 --&gt;</span><br><span class="line">  &lt;public type=&quot;attr&quot; name=&quot;bracketColor&quot; id=&quot;0x03010000&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- Declared at vendor/zowee/proprietary/framework/base/res/res/values/colors.xml:4 --&gt;</span><br><span class="line">  &lt;public type=&quot;color&quot; name=&quot;zui_common_default_hint&quot; id=&quot;0x03030000&quot; /&gt;</span><br><span class="line">  &lt;!-- Declared at vendor/zowee/proprietary/framework/base/res/res/values/colors.xml:6 --&gt;</span><br><span class="line">  &lt;public type=&quot;color&quot; name=&quot;zui_common_default_textcolor&quot; id=&quot;0x03030001&quot; /&gt;</span><br><span class="line">  &lt;!-- Declared at vendor/zowee/proprietary/framework/base/res/res/values/colors.xml:9 --&gt;</span><br><span class="line">  &lt;public type=&quot;color&quot; name=&quot;zui_common_activited_textcolor&quot; id=&quot;0x03030002&quot; /&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></code></pre><ol start="2">
<li><p>另外如果想作为私有的ID资源则可以放在<code>values/symbols.xml</code>中</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;resources&gt;</span><br><span class="line">  &lt;!-- We don&apos;t want to publish private symbols in com.mediatek.R as part of the</span><br><span class="line">       SDK.  Instead, put them here. --&gt;</span><br><span class="line">  &lt;private-symbols package=&quot;com.zowee.internal&quot; /&gt;</span><br><span class="line">  &lt;java-symbol type=&quot;string&quot; name=&quot;zowee_internal&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过以上步骤之后，可在所有的应用中通过<code>android:text=&quot;@com.zowee:string/zowee&quot;</code>访问自定义的资源，在java代码中通过<code>int z =com.zowee.R.string.zowee</code>直接访问资源ID。<br>另附mtk提供的diff包，如果有什么不对的，可以对比查证<br><a href="/media/mtkcustomer-res-L.zip">mtk提供的diff包</a></p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2015/09/16/Test Driven Development Learning one/">TDD测试驱动开发学习（1）</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2015-09-16
        </span><span class="post-category">
            <a href="/categories/TDD/">TDD</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>说到测试驱动，就好像各种模式一样，你知道她好，但是总是没有好好的去坚持，去实施，这事，就和女人的减肥事业一样，磨练人的意志。<br>让我重新开始决定好好学习TDD原因，最基础的时间条件来说，我最近是比较空闲，处于项目空档期；另外，这几天在看美剧<a href="http://v.baidu.com/tv/22488.htm?video_uri=tv.basic.002211.1427779458.0" target="_blank" rel="noopener">《硅谷》(SILICON VALLEY)</a>。其中有一集就是，有个小毛孩把男主的程序数据库全毁了，男主花了好大心事修复，而最后一个镜头就是，他的所有测试用例，一排绿灯通过，这下，他才开始放心揍那个高科技骗子。虽然这个镜头只有一秒不到的时间，但这个镜头在我还算幼小的心灵，烙下了一个我要好好学TDD的念头，哈哈哈O(∩_∩)O哈哈~</p>
<h1 id="从0开始"><a href="#从0开始" class="headerlink" title="从0开始"></a>从0开始</h1><p>我follow的这本书是<a href="http://book.douban.com/subject/5326182/" target="_blank" rel="noopener">测试驱动开发的艺术</a>，
以下是我根据书中内容，一步一步敲打代码的步骤总结，只为了，让自己梳理一下。</p>
<h1 id="Android-studio-添加-junit-测试"><a href="#Android-studio-添加-junit-测试" class="headerlink" title="Android studio 添加 junit 测试"></a>Android studio 添加 junit 测试</h1><p>当然，书里面没有讲怎么在 Android studio 集成IDE中添加junit测试，下面是我摸索的结果。</p>
<ol>
<li><p>创建一个Android项目，这里，也可以不是，随便java项目也可以，我们只是做一个基本的java Junit测试的demo程序而已。我创建的是一个Android的项目按AS的模板默认设置就可以；默认的项目目录结构如下图（采用project视图）：</p>
<p> <img src="http://7xl98n.com1.z0.glb.clouddn.com/android_project.jpg" alt></p>
</li>
<li><p>打开<code>build.gradle</code>文件，将junit:junit:4.12加入编译</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</span><br><span class="line">    compile &apos;com.android.support:appcompat-v7:23.0.0&apos;</span><br><span class="line">    compile  &apos;junit:junit:4.12&apos;</span><br><span class="line">    testCompile &apos;junit:junit:4.12&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 然后点击<code>Sync Project with Grandle files</code>的那个图标按钮，这个时候，我们就可以在代码中访问<code>@Test</code>了</p>
<pre><code>package com.example.lynn.myapplication;
import org.junit.Test;

/**
 * Created by lynn8570 on 2015-9-16.
 * mail: lynn8570@gmail.com
 */
public class TestDemo {
    @Test
    public void testOne() throws  Exception{

    }
}</code></pre></li>
<li><p>告诉编译器，你的测试代码在哪里，一般android项目的默认测试代码放在<code>/src/androidTest/java</code>中，因此我们需要在gradle文件中添加如下内容：</p>
<pre><code>android {
 sourceSets{
    test {
        java.srcDir file(&apos;src/androidTest/java&apos;)
    }
}
}</code></pre></li>
<li><p>由于我们只是运行junit测试，而android默认的测试是<code>Android Instrumentation Tests</code>，所以需要在运行测试的时候，点击<code>Build Variants</code>（一般在左下角），将<code>Test Artifact</code>设置为<code>Unit Tests</code>。</p>
</li>
<li><p>随便写一个测试看下我们的测试可否运行，代码如下：</p>
<pre><code>@Test
public void testOne() throws  Exception{
    assertNotNull(new Object());
}</code></pre></li>
<li><p>配置测试运行参数，在<code>Run/Debug Configurations</code>对话框中，点击“+”号，添加Junit运行配置。你可以只运行一个class或者运行package下所有的包。</p>
</li>
<li><p>运行测试，测试通过配置完成，event log输出如下内容的话，表示前期准备OK</p>
<pre><code>13:46:00 Compilation completed successfully in 4s 393ms
13:46:00 Tests Passed: 1 passed in 0.032 s</code></pre></li>
</ol>
<h1 id="可能会遇到一些错误"><a href="#可能会遇到一些错误" class="headerlink" title="可能会遇到一些错误"></a>可能会遇到一些错误</h1><ul>
<li><p>默认的ApplicationTestCase未删掉，因为AS默认创建的Android项目是有一个默认的ApplicationTestCase测试，由于我们将build variantants中的Test Artifact改为Unit Test，会造成报错如下：</p>
<pre><code>Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: android/test/ApplicationTestCase
 at java.lang.ClassLoader.defineClass1(Native Method)
 at java.lang.ClassLoader.defineClass(ClassLoader.java:800)
 at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
 at java.net.URLClassLoader.defineClass(URLClassLoader.java:449)
 at java.net.URLClassLoader.access$100(URLClassLoader.java:71)
 at java.net.URLClassLoader$1.run(URLClassLoader.java:361)
 at java.net.URLClassLoader$1.run(URLClassLoader.java:355)
 at java.security.AccessController.doPrivileged(Native Method)
 at java.net.URLClassLoader.findClass(URLClassLoader.java:354)
 at java.lang.ClassLoader.loadClass(ClassLoader.java:425)
 at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
 at java.lang.ClassLoader.loadClass(ClassLoader.java:358)
 at java.lang.Class.forName0(Native Method)
 at java.lang.Class.forName(Class.java:270)
 at com.intellij.junit4.JUnit4TestRunnerUtil.loadTestClass(JUnit4TestRunnerUtil.java:302)
 at com.intellij.junit4.JUnit4TestRunnerUtil.appendTestClass(JUnit4TestRunnerUtil.java:286)
 at com.intellij.junit4.JUnit4TestRunnerUtil.buildRequest(JUnit4TestRunnerUtil.java:80)
 at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:39)
 at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:212)
 at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:68)
 at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
 at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
 at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
 at java.lang.reflect.Method.invoke(Method.java:606)
 at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)
Caused by: java.lang.ClassNotFoundException: android.test.ApplicationTestCase
 at java.net.URLClassLoader$1.run(URLClassLoader.java:366)
 at java.net.URLClassLoader$1.run(URLClassLoader.java:355)
 at java.security.AccessController.doPrivileged(Native Method)
 at java.net.URLClassLoader.findClass(URLClassLoader.java:354)
 at java.lang.ClassLoader.loadClass(ClassLoader.java:425)
 at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
 at java.lang.ClassLoader.loadClass(ClassLoader.java:358)
 ... 25 more</code></pre></li>
</ul>
<p>如果这样，请删除默认的ApplicationTestCase</p>
<ul>
<li><p>如果运行时，提示错误信息：</p>
<pre><code>Error running TestDemo: Class &apos;com.example.lynn.myapplication.TestDemo&apos; not found in module &apos;app&apos;</code></pre><p>  检查是否添加了</p>
<pre><code>sourceSets{
        test {
            java.srcDir file(&apos;src/androidTest/java&apos;)
        }
    }</code></pre></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上面的环境准备，基本就可以按照书本里面的步骤开始一步步敲代码啦~~</p>
<p>至此书本上的第一个demo演练已经过了一遍，主要是模板解析的一个演示程序，在不断写测试代码，完成功能，重构优化的一轮轮中，通过测试代码作为基本保障，让程序代码不断的完善。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2015/09/14/some memory leaks that no need to be fixed/">Leakcanary部分泄露警报无需修复</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2015-09-14
        </span><span class="post-category">
            <a href="/categories/android/">android</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用leakcanary检查内存泄露之后，由于他的工作原理，造成所有的在上下文关闭之后，还未被释放的资源就会引爆内存泄露通知。但是不是所有的泄露都需要修复的。下面总结几个我的血泪史，希望以后不要重蹈覆辙。</p>
<p>#InputMethodManager.sInstance泄露</p>
<p>输入法泄露，具体的泄露路径类似于</p>
<p><img src="http://7xl98n.com1.z0.glb.clouddn.com/M_1.jpg" alt></p>
<p>提示InputMethodManager.sInstance这个静态实例可能通过各种路径对context进行了泄露。具体的路径可能会不一样，但是归根到最后都是提示InputMethodManager.sInstance静态引用泄露。<br>通过网上搜索，可能有类似的修复，如下<br>    public static final class TypedObject<br>    {<br>        private final Object object;<br>        private final Class type;</p>
<pre><code>    public TypedObject(final Object object, final Class type)
    {
    this.object = object;
    this.type = type;
    }

    Object getObject()
    {
        return object;
    }

    Class getType()
    { 
        return type;
    }
}

public static void invokeMethodExceptionSafe(final Object methodOwner, final String method, final TypedObject... arguments)
{
    if (null == methodOwner)
    {
        return;
    }

    try
    {
        final Class&lt;?&gt;[] types = null == arguments ? new Class[0] : new Class[arguments.length];
        final Object[] objects = null == arguments ? new Object[0] : new Object[arguments.length];

        if (null != arguments)
        {
            for (int i = 0, limit = types.length; i &lt; limit; i++)
            {
                types[i] = arguments[i].getType();
                objects[i] = arguments[i].getObject();
            }
        }

        final Method declaredMethod = methodOwner.getClass().getDeclaredMethod(method, types);

        declaredMethod.setAccessible(true);
        declaredMethod.invoke(methodOwner, objects);
    }
    catch (final Throwable ignored)
    {
    }
}

public static void fixInputMethodManager(Activity activity)
{
    final Object imm = activity.getSystemService(Context.INPUT_METHOD_SERVICE);

    final Reflector.TypedObject windowToken
        = new Reflector.TypedObject(activity.getWindow().getDecorView().getWindowToken(), IBinder.class);

    Reflector.invokeMethodExceptionSafe(imm, &quot;windowDismissed&quot;, windowToken);

    final Reflector.TypedObject view
        = new Reflector.TypedObject(null, View.class);

    Reflector.invokeMethodExceptionSafe(imm, &quot;startGettingWindowFocus&quot;, view);
}</code></pre><p>主要通过反射，修复内存泄露。</p>
<p>但是，下面的话，非常重要，非常重要，非常重要，重要的事情说三遍：这个属于系统级别的泄露，也就是说，你不泄露，别人也会泄露，而且整个android系统，只保留一个static instance的引用，所以这个修复，对整个系统的内存没有太大的改善。而且这个修复的隐患是，你有可能会在页面跳转的时候，遇到各种不可预测的编辑框无法获取焦点的问题。所以，我建议，这个泄露，可以忽略。</p>
<h1 id="AsyncQueryHandler-没有quit"><a href="#AsyncQueryHandler-没有quit" class="headerlink" title="AsyncQueryHandler 没有quit"></a>AsyncQueryHandler 没有quit</h1><p>有时候我们会遇到HandlerThread没有quit而爆出的泄露，泄露路径如下：</p>
<p><img src="http://7xl98n.com1.z0.glb.clouddn.com/M_2.jpg" alt></p>
<p>而android系统中有个AsyncQueryWorker从源代码看</p>
<pre><code>public AsyncQueryHandler(ContentResolver cr) {
    super();
    mResolver = new WeakReference&lt;ContentResolver&gt;(cr);
    synchronized (AsyncQueryHandler.class) {
        if (sLooper == null) {
            HandlerThread thread = new HandlerThread    (&quot;AsyncQueryWorker&quot;);
            thread.start();
            sLooper = thread.getLooper();
        }
    }
    mWorkerThreadHandler = createHandler(sLooper);
}</code></pre><p>这个名为AsyncQueryWorker的HandlerThread自从start之后就没人管了。这个时候，leakcanary也会提示泄露。<br>于是我曾自作聪明，通过反射将这个sLooper强制退出，代码如下：</p>
<pre><code>//linlian@2015.06.01 release static sLooper in AsyncQueryHandler
public static void fixAsyncQueryWorker(){
    Field sLooperCached = null;
    try {
        sLooperCached = Class.forName(&quot;android.content.AsyncQueryHandler&quot;).getDeclaredField(&quot;sLooper&quot;);
        sLooperCached.setAccessible(true);
    } catch (Exception ex) {
        ex.printStackTrace();
    }
    if (sLooperCached == null) return;
    Looper looper = null;
     try {
        // Get reference to the sLooperCached 
        looper = (Looper)sLooperCached.get(null);
        if(looper!=null){
            looper.quit();
            sLooperCached.set(null,null);
        }
    } catch (Exception ex) {
        ex.printStackTrace();
    }</code></pre><p>这个修复的惨痛后果是，有些后台线程直接结束了，所以，对于AsyncQueryHandler的泄露，我也是建议不修复。</p>
<h1 id="TextLine-sCached-泄露"><a href="#TextLine-sCached-泄露" class="headerlink" title="TextLine.sCached 泄露"></a>TextLine.sCached 泄露</h1><p><img src="http://7xl98n.com1.z0.glb.clouddn.com/M_3.jpg" alt></p>
<p>和inputManager一样，这个泄露，属于系统的静态引用而造成的泄露，但是这个泄露的修复，目前没有发现什么不良的影响，但是泄露修复的价值意义不知道大不大，也是你不泄露，别人也会泄露，反正总有一个这样的引用存在的。修复的效果也不是很明显<br>修复代码如下</p>
<pre><code>public static void clearTextLineCache(){
    Field textLineCached = null;
    try {
        textLineCached = Class.forName(&quot;android.text.TextLine&quot;).getDeclaredField(&quot;sCached&quot;);
        textLineCached.setAccessible(true);
    } catch (Exception ex) {
        ex.printStackTrace();
    }
    if (textLineCached == null) return;
    Object cached = null;
    try {
        // Get reference to the TextLine sCached array.
        cached = textLineCached.get(null);
    } catch (Exception ex) {
        ex.printStackTrace();
    }
    if (cached != null) {
        // Clear the array.
        for (int i = 0, size = Array.getLength(cached); i &lt; size; i ++) {
            Array.set(cached, i, null);
        }
    }
}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>LeakCanary是一个很好检查内存泄露的工具，但不是所有的泄露都需要修复，有些事android系统的泄露bug，通过各种方式曲线救国之后，不一定会达到一个很好的内存改善结果，所以干脆不要去动他，以免引起不可预测的运行异常。只有自己非常肯定的，由于使用不规范等引起的内存泄露才是我们重点关注的部分</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2015/09/02/Common memory leaks/">常见的内存泄露</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2015-09-02
        </span><span class="post-category">
            <a href="/categories/android/">android</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p>利用<a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">LeakCanary</a>检查内存泄露，在出现内存泄露的时候，会弹出内存泄露提醒，点击可显示内存泄露路径。现在我来归纳一下自己遇到的几种常见的内存泄露类型吧<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># 常见的泄露类型 #</span><br><span class="line"></span><br><span class="line">- 对context，activity的static的引用</span><br><span class="line">	</span><br><span class="line">	没必要的static，移出static</span><br><span class="line">	</span><br><span class="line">	![](http://7xl98n.com1.z0.glb.clouddn.com/QQ截图20150806154414.jpg)</span><br><span class="line"></span><br><span class="line">	上图中`RawContactEditorView.mContext`有时候存在这种没有必要的static应用，看到static的时候，请提高一百八十分的警惕，寻根是否有必要，是否可以用appcontext来替代等，以便防止对activity context的泄露</span><br><span class="line"></span><br><span class="line">- 必要的static，试着用appcontext来替代</span><br><span class="line"></span><br><span class="line">	![](http://7xl98n.com1.z0.glb.clouddn.com/QQ截图20150806154825.jpg)</span><br><span class="line"></span><br><span class="line">	上图中`ContactListFilterController.sFilterController`为静态，而这sFilterController对activity的context存在引用，从而造成了context的泄露。但是为了实现单例，代码又不得不保留static，对于这种情况查看对context引用的实际用处，有时候你就回发现，很多时候可以appcontext来替代。</span><br><span class="line"></span><br><span class="line">- 必须对activity static应用，控制生命周期</span><br><span class="line"></span><br><span class="line">	![](http://7xl98n.com1.z0.glb.clouddn.com/QQ截图20150901135429.jpg)</span><br><span class="line"></span><br><span class="line">	上图中，mDialog为静态，在外部需要直接访问必须为静态，dialog又对activity的context进行了引用，无法用appcontext来替代，像这种情况，可以在相应activity的生命周期中对引用进行解除。就是我们熟悉的`onDestroy()`中设置null，remove之类的操作</span><br><span class="line"></span><br><span class="line">- 非静态的内部类</span><br><span class="line"></span><br><span class="line">	![](http://7xl98n.com1.z0.glb.clouddn.com/QQ截图20150806154825.jpg)</span><br><span class="line">	</span><br><span class="line">	在activity中直接声明的内部类，通常对activity保有一个this的引用，一次容易照成泄露，如果不想去控制这个mPhoneStateListener的生命周期，就采用将其变为静态内部类，通过WeakReference来保留对this的引用。例如：</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">public static class PhoneStateListenerImpl extends PhoneStateListener &#123;</span><br><span class="line">		protected final WeakReference&lt;DialpadFragment&gt; mDialpadFragment; </span><br><span class="line">		public PhoneStateListenerImpl(DialpadFragment fragment)&#123;</span><br><span class="line">			 mDialpadFragment = new WeakReference&lt;DialpadFragment&gt;(fragment);</span><br><span class="line">		&#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void onCallStateChanged(int state, String incomingNumber) &#123;</span><br><span class="line">		 	final DialpadFragment fragment = mDialpadFragment.get();</span><br><span class="line">			if(fragment==null)return;</span><br><span class="line">			if(fragment.getActivity()==null)return;</span><br><span class="line">            	…….// fragment!=null.</span><br><span class="line">			Balabala…….</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">- HandlerThread 没有quit，cursor没有close，网络连接、IO流没有及时关闭</span><br><span class="line"></span><br><span class="line"># 总结 #</span><br><span class="line"></span><br><span class="line">这些知识一些常见的内存泄露例子，平时我们经常见的在onDestroy的时候，unregistered，close，removelistener之类的操作都是避免因一直引用context而引发内存泄露；另外就是static变量的慎用，还有就是非静态内部类慎用。</span><br><span class="line">遇到内漏的时候，主要是还是根据路径查看代码，具体问题，具体分析~~~</span><br></pre></td></tr></table></figure></p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2015/09/01/use leakcanary for memory leak check/">如何使用leakcanary进行内存检查</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2015-09-01
        </span><span class="post-category">
            <a href="/categories/android/">android</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h1 id="LeakCanary介绍"><a href="#LeakCanary介绍" class="headerlink" title="LeakCanary介绍"></a>LeakCanary介绍</h1><p>如官网所说<a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">LeakCanary</a>is a memory leak detection library for Android and Java.</p>
<p>有了他，我们用于做内存泄露的检查就方便了许多，经过部署和添加之后，运行我们的应用，经过常规的使用操作，如果应用存在内存泄露，那么leakcanary将会发出notification提醒，点击提醒，可以进入leakcanary的泄露路径界面，将内存泄露路径打出来。</p>
<h1 id="如何添加leakcanary"><a href="#如何添加leakcanary" class="headerlink" title="如何添加leakcanary"></a>如何添加leakcanary</h1><h2 id="适用于eclipse的使用方式"><a href="#适用于eclipse的使用方式" class="headerlink" title="适用于eclipse的使用方式"></a>适用于eclipse的使用方式</h2><p>github上的代码，采用的是gradle来build的，之前我还在用eclipse的时候，还弄了一份适用于eclipse目录结构的代码，然后作为jar包提供给应用使用，检查应用的内存泄露情况。<br><a href="/media/DisplayLeak.rar">下载转换后的代码</a></p>
<ol>
<li>将下载好的代码，导入到eclipse中；</li>
<li>将DisplayLeak作为lib使用，打开DisplayLeak的properties对话框，选择android勾选 Is Library</li>
<li>在需要使用内存泄露的应用中，同样打开properties对话框，选择android在library中选择add,添加刚才的DisplayLeak作为lib使用</li>
</ol>
<h2 id="Android-studio使用"><a href="#Android-studio使用" class="headerlink" title="Android studio使用"></a>Android studio使用</h2><p>以上只是因为当时工作的特殊集成环境，于是走了一条曲线救国的道路，现在用AS，只需在dependencies添加写代码就可以直接使用了，好用到哭<del>(&gt;_&lt;)</del></p>
<p>你只需要在app module的build.gradle文件中添加如下依赖，就可以使用leakcanary了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="function">compile <span class="title">fileTree</span><span class="params">(dir: <span class="string">'libs'</span>, include: [<span class="string">'*.jar'</span>])</span></span></span><br><span class="line"><span class="function">    compile 'com.android.support:appcompat-v7:23.0.0'</span></span><br><span class="line"><span class="function">    compile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3.1'</span></span><br><span class="line"><span class="function">    releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3.1'</span></span><br><span class="line"><span class="function">    releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3.1'</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><ul>
<li><p>添加组件到AndroidManifest.xml</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- leak canary--&gt;</span><br><span class="line">	&lt;service</span><br><span class="line">           android:name=&quot;com.squareup.leakcanary.internal.HeapAnalyzerService&quot;</span><br><span class="line">           android:enabled=&quot;false&quot;</span><br><span class="line">           android:process=&quot;:leakcanary&quot; /&gt;</span><br><span class="line">       &lt;service</span><br><span class="line">           android:name=&quot;com.squareup.leakcanary.internal.DisplayLeakService&quot;</span><br><span class="line">           android:enabled=&quot;false&quot; /&gt;</span><br><span class="line"></span><br><span class="line">       &lt;activity</span><br><span class="line">           android:name=&quot;com.squareup.leakcanary.internal.DisplayLeakActivity&quot;</span><br><span class="line">           android:enabled=&quot;true&quot;</span><br><span class="line">           android:icon=&quot;@drawable/__leak_canary_icon&quot;</span><br><span class="line">           android:label=&quot;@string/__leak_canary_display_activity_label&quot;</span><br><span class="line">           android:taskAffinity=&quot;com.squareup.leakcanary&quot;</span><br><span class="line">           android:theme=&quot;@style/__LeakCanary.Base&quot; &gt;</span><br><span class="line">       &lt;/activity&gt;</span><br><span class="line">&lt;!-- leak canary--&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>项目中加入LeakCanary代码</p>
<ul>
<li><p>检查Activity泄露<br>检查activity泄露只需要在application中添加如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.app.Application;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> com.squareup.leakcanary.LeakCanary;</span><br><span class="line"><span class="keyword">import</span> com.squareup.leakcanary.RefWatcher;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2015-8-31.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RefWatcher <span class="title">getRefWatcher</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        ExampleApplication application = (ExampleApplication) context.getApplicationContext();</span><br><span class="line">        <span class="keyword">return</span> application.refWatcher;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> RefWatcher refWatcher;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        refWatcher = LeakCanary.install(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查fragment泄露<br>在fragment的onDestroy方法中添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public abstract class BaseFragment extends Fragment &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void onDestroy() &#123;</span><br><span class="line">   	super.onDestroy();</span><br><span class="line">   	RefWatcher refWatcher = ExampleApplication.getRefWatcher(getActivity());</span><br><span class="line">   	refWatcher.watch(this);</span><br><span class="line"> 		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h1 id="LeakCanary原理"><a href="#LeakCanary原理" class="headerlink" title="LeakCanary原理"></a>LeakCanary原理</h1><p>所有的这些准备结束之后，我们只需要对编译的debug版本的app进行常规的一些操作，当所检测的应用出现内存泄露的时候，LeakCanary将自动的发出内存泄露的通知。</p>
<p>Leakcanary的工作原理：</p>
<ol>
<li>在onDestroy中创建了KeyedWeakReference的对象来监视需要监视的fragment，activity或其他一些对象等；进行弱引用</li>
<li>在一个后台线程，会去查看是否有这个KeyedWeakReference对象，是否被cleared了；如果没有，则强制执行GC</li>
<li>如果GC之后，还是没有clear这个reference，那么久保存一个heap堆栈的hrof文件；</li>
<li>然后一个独立的HeapAnalyzerService服务进程将启动，并通过HeapAnalyzer集成HAHA另外一个开源项目的代码来对hrof进行自动的分析。</li>
<li>HeapAnalyzer将去定位KeyedWeakReference</li>
<li>HeapAnalyzer计算出这个引用到GC root一条最短的强引用链路，来确定是否存在leak</li>
<li>最终再讲这个结果传递给DisplayLeakService并发出通知，显示泄露路径 </li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Leakcanary方便我们查找内存泄露路径，当发现内存泄露之后，我们需要根据具体的泄露路径来解决泄露问题，下一篇，我会总结下在检查出发现的常见的泄露类型 </p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2015/08/21/payme/">金主爸爸来打赏</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2015-08-21
        </span><span class="post-category">
            <a href="/categories/hugo/">hugo</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p>金主爸爸来打赏</p>
          <div class="read-more">
            <a href="/2015/08/21/payme/" class="read-more-link">阅读更多</a>
          </div>
        </div></article>
      <nav class="pagination"><a class="prev" href="/page/3/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">上一页</span>
      </a>
    </nav></section></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        <a href="https://github.com/ahonn" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2015 - 2019<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">lynn8570</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
