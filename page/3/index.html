<!DOCTYPE html>
<html lang>
  <head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="android"><meta name="keywords" content="android"><link rel="alternate" href="/default" title="Lynn8570's Blog"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0">
<link rel="canonical" href="https://lynn8570.github.io/page/3/">

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css"><link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css">
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0">

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":true,"latex":false};
</script>

    <title>Lynn8570's Blog</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Lynn8570's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Lynn8570's Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><section id="posts" class="posts"><article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/02/26/Understanding the Treasure Hunt sample game/">Understanding the Treasure Hunt sample game</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-26
        </span><span class="post-category">
            <a href="/categories/ANDROID/">ANDROID</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h1 id="Google-VR-SDK-寻宝游戏code-overview"><a href="#Google-VR-SDK-寻宝游戏code-overview" class="headerlink" title="Google VR SDK 寻宝游戏code overview"></a>Google VR SDK 寻宝游戏code overview</h1><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul>
<li>硬件要求：<ul>
<li>Daydream平台：可支持Daydream的手机：Galaxy note8，MotoZ force，pixel，Axon7 ZTE，Moto Z，Mate 9，LG v30等 和  Daydream Viewer</li>
<li>Cardboard平台，运行android 4.4 api19以上的手机和一个 Cardboard viewer</li>
</ul>
</li>
<li>软件要求：<ul>
<li>android sdk 25以上</li>
<li>Google VR SDK</li>
</ul>
</li>
</ul>
<h2 id="运行Google-VR-SDK"><a href="#运行Google-VR-SDK" class="headerlink" title="运行Google VR SDK"></a>运行Google VR SDK</h2><p>运行<strong>samples-sdk-treasurehunt</strong> </p>
<p>在android 4.4以上就可以运行，但是不一定能用，例如如果没有Gsensor数据等无法进行运动捕捉。虽然可以正常运行，但是无法进行体验。</p>
<h2 id="Manifest-文件"><a href="#Manifest-文件" class="headerlink" title="Manifest 文件"></a>Manifest 文件</h2><ul>
<li><p>VR应用属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest ...&gt;</span><br><span class="line">    &lt;uses-sdk android:minSdkVersion=&quot;19&quot; android:targetSdkVersion=&quot;24&quot;/&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;uses-feature android:glEsVersion=&quot;0x00020000&quot; android:required=&quot;true&quot; /&gt;</span><br><span class="line">    &lt;uses-feature android:name=&quot;android.software.vr.mode&quot; android:required=&quot;false&quot;/&gt;</span><br><span class="line">    &lt;uses-feature android:name=&quot;android.hardware.vr.high_performance&quot; android:required=&quot;false&quot;/&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>

<p>Google VR SDK 支持的最低版本为api 19, 另外Daydream 应用的target API 要24或者以上级别。需 OpenGL ES 2.0 支持，可正确渲染VR内容。<code>&lt;uses-feature android:name=&quot;android.software.vr.mode&quot; android:required=&quot;false&quot;/&gt;</code>和<code>&lt;uses-feature android:name=&quot;android.hardware.vr.high_performance&quot; android:required=&quot;false&quot;/&gt;</code> 由 Android N加入的新特性，前者表示需要使用Android VR模式，后者表示需要可支持Daydream的设备。</p>
<p>对于没有Google VR服务的设备，需要安装Google VR 服务，才可以将可支持Daydream的设备与对应的VR viewer配对。因此还需要添加<code>READ_EXTERNAL_STORAGE</code>权限。</p>
</li>
</ul>
<ul>
<li><p>VR Activity 属性</p>
<p>Activity也需要添加一些属性声明，才可兼容Daydream</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    android:name=&quot;.MyActivity&quot;</span><br><span class="line">    android:screenOrientation=&quot;landscape&quot;</span><br><span class="line">    android:enableVrMode=&quot;@string/gvr_vr_mode_component&quot;</span><br><span class="line">    android:theme=&quot;@style/VrActivityTheme&quot;</span><br><span class="line">    android:resizeableActivity=&quot;false&quot;</span><br><span class="line">    android:configChanges=&quot;density|keyboardHidden|navigation|orientation|screenSize|uiMode&quot;</span><br><span class="line">    ...&gt;</span><br></pre></td></tr></table></figure>

<p><code>enableVrMode</code>属性用于启用Android VR 模式，Android 7.0 N 引入的功能特性，用于支持高性能的移动 VR 应用。该属性表示，当启动Activity的时候，系统需要自动启动VR模式。</p>
<blockquote>
<p>启动 VR activity的时候，屏幕会有些轻微的闪烁，这是因为当启动VR模式的时候，Android需要切换到低持久性模式显示。</p>
</blockquote>
<p><code>android:theme=&quot;@style/VrActivityTheme&quot;</code>确保Activity在VR转换期间正常运行，<code>android:resizeableActivity=&quot;false&quot;</code>表明Activity不可调整显示大小，不与其他的Activity分屏。landscape表明屏幕需要横屏显示。</p>
<p><code>configChanges</code>可避免activity因为一些配置变化而造成activity的重新创建。</p>
<p>Google VR应用基本和要求：</p>
<p><a href="https://developers.google.com/vr/distribute/daydream/app-quality" target="_blank" rel="noopener">https://developers.google.com/vr/distribute/daydream/app-quality</a></p>
<ul>
<li><p>设计要求：</p>
<ol>
<li>物体对象需要放置在一定的距离，以便用户可以看清楚而不是看到两张图片。如果需要辅助文字，需要保证文字的可读性。建议物体对象需要放置在0.5米距离以上</li>
<li>需要维护头部动作位置追踪</li>
<li>地平线维持，不至于倾斜</li>
<li>相机操作需要用户启动，但可以不是一直直接的控制操作</li>
<li>app不干涉系统级别的复位行为</li>
<li>…….</li>
</ol>
</li>
<li><p>功能要求</p>
<ol>
<li><p>使用支持的VR SDK版本</p>
</li>
<li><p>使用Daydream API进行activity切换<code>daydreamApi.launchVrHomescreen();</code>  <code>daydreamApi.launchInVr(componentName);</code></p>
</li>
<li><p>不请求nfc权限，应用不能使用nfc权限，而是Daydream平台需要使用nfc功能来进行配对操作。</p>
</li>
<li><p>应用的manifest清单文件中，需要设置正确的VR activity样式：禁止android默认的windowmanager的切换动画；隐藏系统级的ui元素，例如系统状态栏，导航栏和键盘等；采用landscape，禁止方向转化；禁用多窗口支持。</p>
<p><code>android:theme=&quot;@style/VrActivityTheme&quot;</code>可用于禁止切换动画和隐藏系统ui;</p>
<p><code>android:enableVrMode=&quot;@string/gvr_vr_mode_component&quot;</code>可用于设置仅从Daydream Home或者另外一个VR activities来启动Activity，以便得到更快的切换。</p>
<p>示例的activity清单代码可查看前面的示例。</p>
<p>需要显示在VR Home中的Daydream activity需要设置<code>com.google.intent.category.DAYDREAM</code>，如果不想显示的VR Home中，只要设置<code>android.intent.action.VIEW</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity</span><br><span class="line">    ... &gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class="line">        &lt;category android:name=&quot;com.google.intent.category.DAYDREAM&quot;/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>根据平台设置硬件特性，对于Daydream的应用，以下硬件特性都是必须的。对于某些具有cardboard模式的VR则为可选的。</p>
<pre><code>android:glEsVersion=&quot;0x00020000&quot;
android.hardware.sensor.gyroscope
android.hardware.sensor.accelerometer
android.hardware.vr.high_performance
android.software.vr.mode</code></pre></li>
</ul>
</li>
</ul>
<pre><code>Examples

Application only supports Daydream:

&lt;uses-feature android:glEsVersion=&quot;0x00020000&quot; android:required=&quot;true&quot; /&gt;
&lt;uses-feature android:name=&quot;android.hardware.sensor.accelerometer&quot; android:required=&quot;true&quot; /&gt;
&lt;uses-feature android:name=&quot;android.hardware.sensor.gyroscope&quot; android:required=&quot;true&quot; /&gt;
&lt;uses-feature android:name=&quot;android.hardware.vr.high_performance&quot; android:required=&quot;true&quot; /&gt;
&lt;uses-feature android:name=&quot;android.software.vr.mode&quot; android:required=&quot;true&quot; /&gt;

Application supports both Daydream and Cardboard devices:

&lt;uses-feature android:glEsVersion=&quot;0x00020000&quot; android:required=&quot;true&quot; /&gt;
&lt;uses-feature android:name=&quot;android.hardware.sensor.accelerometer&quot; android:required=&quot;true&quot; /&gt;
&lt;uses-feature android:name=&quot;android.hardware.sensor.gyroscope&quot; android:required=&quot;true&quot; /&gt;
&lt;uses-feature android:name=&quot;android.hardware.vr.high_performance&quot; android:required=&quot;false&quot; /&gt;
&lt;uses-feature android:name=&quot;android.software.vr.mode&quot; android:required=&quot;false&quot; /&gt;

Application&apos;s VR mode is optional:

&lt;uses-feature android:glEsVersion=&quot;0x00020000&quot; android:required=&quot;false&quot; /&gt;
&lt;uses-feature android:name=&quot;android.hardware.sensor.accelerometer&quot; android:required=&quot;false&quot; /&gt;
&lt;uses-feature android:name=&quot;android.hardware.sensor.gyroscope&quot; android:required=&quot;false&quot; /&gt;
&lt;uses-feature android:name=&quot;android.hardware.vr.high_performance&quot; android:required=&quot;false&quot; /&gt;
&lt;uses-feature android:name=&quot;android.software.vr.mode&quot; android:required=&quot;false&quot; /&gt;</code></pre><ul>
<li><p>应用可以正常的暂停</p>
<p>这包括很多常见的操作场景暂停和恢复。例如用户通过控制器或者手机按键按下的Home按钮来立即暂停应用还有音频播放等。数据的保存和恢复。</p>
</li>
<li><p>应用可正常关闭</p>
</li>
</ul>
<ul>
<li><p>平台兼容性</p>
<p>每个activity都必须声明好支持的VR平台；Daydream还是cardboard。两个可兼容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Example of a Daydream/Cardboard Activity --&gt;</span><br><span class="line">&lt;activity ... &gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- This marks the Activity as a Daydream Activity and allows it</span><br><span class="line">             to be launched from the Daydream Home. --&gt;</span><br><span class="line">        &lt;category android:name=&quot;com.google.intent.category.DAYDREAM&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- This marks the Activity as a Cardboard Activity and allows it</span><br><span class="line">             to be launched from the Cardboard app. --&gt;</span><br><span class="line">        &lt;category android:name=&quot;com.google.intent.category.CARDBOARD&quot; /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- This allows this Activity to be launched from the traditional</span><br><span class="line">             Android 2D launcher as well. Remove it if you do not want</span><br><span class="line">             this Activity to be launched directly from the 2D launcher. --&gt;</span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="继承-GvrActivity"><a href="#继承-GvrActivity" class="headerlink" title="继承 GvrActivity"></a>继承 GvrActivity</h2><p>GvrActivity作为基类可对GoogleVR设备进行简单的集成，可以发布一些事件来与VR环境进行交互并且可以处理创建用于VR渲染的activity的一些通用的细节实现。GvrAcitivity使用的是sticky的沉浸式模式，因为GvrView只能在全屏模式下才可以进行渲染。封装的东西还是比较少的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">package com.google.vr.sdk.base;</span><br><span class="line"></span><br><span class="line">import android.app.Activity;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.view.KeyEvent;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.view.ViewGroup.LayoutParams;</span><br><span class="line">import com.google.vr.cardboard.AndroidNCompat;</span><br><span class="line">import com.google.vr.cardboard.FullscreenMode;</span><br><span class="line">import com.google.vrtoolkit.cardboard.ScreenOnFlagHelper;</span><br><span class="line"></span><br><span class="line">public class GvrActivity extends Activity &#123;//直接集成的普通的activity</span><br><span class="line">    private FullscreenMode fullscreenMode;//全屏的flag设置和兼容模式</span><br><span class="line">    private final ScreenOnFlagHelper screenOnFlagHelper = new ScreenOnFlagHelper(this);</span><br><span class="line">    //在resume的启动sensor相关的监听</span><br><span class="line">    private GvrView cardboardView;</span><br><span class="line">    private boolean androidVrModeEnabled;</span><br><span class="line"></span><br><span class="line">    public GvrActivity() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setGvrView(GvrView gvrView) &#123;</span><br><span class="line">        this.setGvrView(gvrView, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setGvrView(GvrView gvrView, boolean enableVrModeFallbacks) &#123;</span><br><span class="line">        if (this.cardboardView != gvrView) &#123;</span><br><span class="line">            if (this.cardboardView != null) &#123;</span><br><span class="line">                this.cardboardView.setOnCardboardTriggerListener((Runnable)null);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.cardboardView = gvrView;</span><br><span class="line">            boolean enableAndroidVrMode = gvrView != null;</span><br><span class="line">            this.androidVrModeEnabled = AndroidNCompat.setVrModeEnabled(this, enableAndroidVrMode, enableVrModeFallbacks ? 1 : 0) &amp;&amp; enableAndroidVrMode;</span><br><span class="line">            if (gvrView != null) &#123;</span><br><span class="line">                gvrView.setOnCardboardTriggerListener(new Runnable() &#123;</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        GvrActivity.this.onCardboardTrigger();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public GvrView getGvrView() &#123;</span><br><span class="line">        return this.cardboardView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onCardboardTrigger() &#123;//可重写</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void updateGvrViewerParams(GvrViewerParams newParams) &#123;</span><br><span class="line">        if (this.cardboardView != null) &#123;</span><br><span class="line">            this.cardboardView.updateGvrViewerParams(newParams);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        this.requestWindowFeature(1);</span><br><span class="line">        this.fullscreenMode = new FullscreenMode(this.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void onResume() &#123;</span><br><span class="line">        super.onResume();</span><br><span class="line">        if (this.cardboardView != null) &#123;</span><br><span class="line">            this.cardboardView.onResume();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.fullscreenMode.goFullscreen();</span><br><span class="line">        this.screenOnFlagHelper.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void onPause() &#123;</span><br><span class="line">        super.onPause();</span><br><span class="line">        if (this.cardboardView != null) &#123;</span><br><span class="line">            this.cardboardView.onPause();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.screenOnFlagHelper.stop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        if (this.cardboardView != null) &#123;</span><br><span class="line">            this.cardboardView.setOnCardboardTriggerListener((Runnable)null);</span><br><span class="line">            this.cardboardView.shutdown();</span><br><span class="line">            this.cardboardView = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setContentView(View view) &#123;</span><br><span class="line">        if (view instanceof GvrView) &#123;</span><br><span class="line">            this.setGvrView((GvrView)view);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        super.setContentView(view);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setContentView(View view, LayoutParams params) &#123;</span><br><span class="line">        if (view instanceof GvrView) &#123;</span><br><span class="line">            this.setGvrView((GvrView)view);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        super.setContentView(view, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onBackPressed() &#123;</span><br><span class="line">        super.onBackPressed();</span><br><span class="line">        this.cardboardView.onBackPressed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean onKeyDown(int keyCode, KeyEvent event) &#123;</span><br><span class="line">        return this.shouldSuppressKey(keyCode) || super.onKeyDown(keyCode, event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean onKeyUp(int keyCode, KeyEvent event) &#123;</span><br><span class="line">        return this.shouldSuppressKey(keyCode) || super.onKeyUp(keyCode, event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void onWindowFocusChanged(boolean hasFocus) &#123;</span><br><span class="line">        super.onWindowFocusChanged(hasFocus);</span><br><span class="line">        this.fullscreenMode.onWindowFocusChanged(hasFocus);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setScreenAlwaysOn(boolean enabled) &#123;</span><br><span class="line">        this.screenOnFlagHelper.setScreenAlwaysOn(enabled);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean shouldSuppressKey(int keyCode) &#123;</span><br><span class="line">        if (!this.androidVrModeEnabled) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return keyCode == 24 || keyCode == 25;//处理了音量加减键</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定义GvrView"><a href="#定义GvrView" class="headerlink" title="定义GvrView"></a>定义GvrView</h2><p>GvrView主要用于VR渲染</p>
<ul>
<li>common_ui.xml</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:id=&quot;@+id/ui_layout&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot; &gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;com.google.vr.sdk.base.GvrView</span><br><span class="line">        android:id=&quot;@+id/gvr_view&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:layout_alignParentTop=&quot;true&quot;</span><br><span class="line">        android:layout_alignParentLeft=&quot;true&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void initializeGvrView() &#123;</span><br><span class="line">  setContentView(R.layout.common_ui);//设置xml文件</span><br><span class="line"></span><br><span class="line">  GvrView gvrView = (GvrView) findViewById(R.id.gvr_view);</span><br><span class="line">  gvrView.setEGLConfigChooser(8, 8, 8, 8, 16, 8);</span><br><span class="line">  // Android设备往往支持多种EGL配置，可以使用不同数目的通道(channel)，也可以指定每个通道具有不同数目的位(bits)深度。因此， 在渲染器工作之前就应该指定EGL的配置。如果没有调用的话，那么默认的配置是 RGB_888 surface with a depth buffer depth of at least 16 bits. </span><br><span class="line"></span><br><span class="line">  gvrView.setRenderer(this);</span><br><span class="line">  gvrView.setTransitionViewEnabled(true);//提示页面</span><br><span class="line"></span><br><span class="line">  // Enable Cardboard-trigger feedback with Daydream headsets. This is a simple way of supporting</span><br><span class="line">  // Daydream controller input for basic interactions using the existing Cardboard trigger API.</span><br><span class="line">  //即使用现有的trigger API实现与daydream 头戴式设备的交互。</span><br><span class="line">  gvrView.enableCardboardTriggerEmulation();</span><br><span class="line"></span><br><span class="line">  if (gvrView.setAsyncReprojectionEnabled(true)) &#123;</span><br><span class="line">    // Async reprojection decouples the app framerate from the display framerate,</span><br><span class="line">    // allowing immersive interaction even at the throttled clockrates set by</span><br><span class="line">    // sustained performance mode.</span><br><span class="line">    AndroidCompat.setSustainedPerformanceMode(this, true);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setGvrView(gvrView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="渲染视图"><a href="#渲染视图" class="headerlink" title="渲染视图"></a>渲染视图</h2><p>Google VR 支持两种renderers，GvrView.StereoRendere和GvrView.Renderer。demo中采用的是前者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public interface StereoRenderer &#123;</span><br><span class="line">       @UsedByNative</span><br><span class="line">       void onNewFrame(HeadTransform var1);</span><br><span class="line"></span><br><span class="line">       @UsedByNative</span><br><span class="line">       void onDrawEye(Eye var1);</span><br><span class="line"></span><br><span class="line">       @UsedByNative</span><br><span class="line">       void onFinishFrame(Viewport var1);</span><br><span class="line"></span><br><span class="line">       void onSurfaceChanged(int var1, int var2);</span><br><span class="line"></span><br><span class="line">       void onSurfaceCreated(EGLConfig var1);</span><br><span class="line"></span><br><span class="line">       void onRendererShutdown();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public interface Renderer &#123;</span><br><span class="line">       @UsedByNative</span><br><span class="line">       void onDrawFrame(HeadTransform var1, Eye var2, Eye var3);</span><br><span class="line"></span><br><span class="line">       @UsedByNative</span><br><span class="line">       void onFinishFrame(Viewport var1);</span><br><span class="line"></span><br><span class="line">       void onSurfaceChanged(int var1, int var2);</span><br><span class="line"></span><br><span class="line">       void onSurfaceCreated(EGLConfig var1);</span><br><span class="line"></span><br><span class="line">       void onRendererShutdown();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>实现GvrView.StereoRendere接口饼设置gvrView.setRenderer(this);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class TreasureHuntActivity extends GvrActivity implements GvrView.StereoRendere&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line">    private void init()&#123;</span><br><span class="line">        gvrView.setRenderer(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>void onNewFrame(HeadTransform var1);app 渲染的时候都会调用</li>
<li>void onDrawEye(Eye var1);eye参数不同的时候调用</li>
</ul>
<p>需要扩展相关OpenGL知识</p>
<h2 id="Render实现"><a href="#Render实现" class="headerlink" title="Render实现"></a>Render实现</h2><ul>
<li><p>onSurfaceCreated</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Creates the buffers we use to store information about the 3D world.</span><br><span class="line">  *</span><br><span class="line">  * &lt;p&gt;OpenGL doesn&apos;t use Java arrays, but rather needs data in a format it can understand.</span><br><span class="line">  * Hence we use ByteBuffers.</span><br><span class="line">  *</span><br><span class="line">  * @param config The EGL configuration used when creating the surface.</span><br><span class="line">  */</span><br><span class="line"> @Override</span><br><span class="line"> public void onSurfaceCreated(EGLConfig config) &#123;</span><br><span class="line">    GLES20.glClearColor(0.1f, 0.1f, 0.1f, 0.5f); // 黑色背景.</span><br><span class="line"></span><br><span class="line">   ／／初始化一些buffer</span><br><span class="line">   ByteBuffer bbVertices = ByteBuffer.allocateDirect(WorldLayoutData.CUBE_COORDS.length * 4);</span><br><span class="line">   bbVertices.order(ByteOrder.nativeOrder());</span><br><span class="line">   cubeVertices = bbVertices.asFloatBuffer();</span><br><span class="line">   cubeVertices.put(WorldLayoutData.CUBE_COORDS);</span><br><span class="line">   cubeVertices.position(0);</span><br><span class="line">   。。。。。。</span><br><span class="line">   int vertexShader = loadGLShader(GLES20.GL_VERTEX_SHADER, R.raw.light_vertex);</span><br><span class="line">   int gridShader = loadGLShader(GLES20.GL_FRAGMENT_SHADER, R.raw.grid_fragment);</span><br><span class="line">   int passthroughShader = loadGLShader(GLES20.GL_FRAGMENT_SHADER, R.raw.passthrough_fragment);／／从文件中加载</span><br><span class="line">   </span><br><span class="line">   更多需要扩展下GLES20的相关api</span><br><span class="line">   </span><br><span class="line">  // 另外起一个线程，来对音频文件进行解码</span><br><span class="line">   new Thread(</span><br><span class="line">           new Runnable() &#123;</span><br><span class="line">             @Override</span><br><span class="line">             public void run() &#123;</span><br><span class="line">               </span><br><span class="line">               gvrAudioEngine.preloadSoundFile(OBJECT_SOUND_FILE);//立体音频文件加载</span><br><span class="line">               sourceId = gvrAudioEngine.createSoundObject(OBJECT_SOUND_FILE);</span><br><span class="line">               gvrAudioEngine.setSoundObjectPosition(／／可设置声音发出的位置</span><br><span class="line">                   sourceId, modelPosition[0], modelPosition[1], modelPosition[2]);</span><br><span class="line">               gvrAudioEngine.playSound(sourceId, true /* looped playback */);</span><br><span class="line">               </span><br><span class="line">               gvrAudioEngine.preloadSoundFile(SUCCESS_SOUND_FILE);</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;)</span><br><span class="line">       .start();</span><br><span class="line"> 	</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
</ul>
<ul>
<li><p>onNewFrame</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Prepares OpenGL ES before we draw a frame.</span><br><span class="line">   *</span><br><span class="line">   * @param headTransform The head transformation in the new frame.</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public void onNewFrame(HeadTransform headTransform) &#123;</span><br><span class="line">    setCubeRotation();</span><br><span class="line"></span><br><span class="line">    // Build the camera matrix and apply it to the ModelView.</span><br><span class="line">    Matrix.setLookAtM(camera, 0, 0.0f, 0.0f, CAMERA_Z, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f);</span><br><span class="line"></span><br><span class="line">    headTransform.getHeadView(headView, 0);</span><br><span class="line"></span><br><span class="line">    // Update the 3d audio engine with the most recent head rotation.</span><br><span class="line">    headTransform.getQuaternion(headRotation, 0);</span><br><span class="line">    gvrAudioEngine.setHeadRotation(</span><br><span class="line">        headRotation[0], headRotation[1], headRotation[2], headRotation[3]);</span><br><span class="line">    // Regular update call to GVR audio engine.</span><br><span class="line">    gvrAudioEngine.update();</span><br><span class="line"></span><br><span class="line">    checkGLError(&quot;onReadyToDraw&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>public void onNewFrame(HeadTransform headTransform) 其中HeadTransform封装了头部位置动作信息，可获取<strong>四元数，坐标体系</strong>扩张（扩展知识）</p>
</li>
<li><p>onDrawEye</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Draws a frame for an eye.</span><br><span class="line"> *</span><br><span class="line"> * @param eye The eye to render. Includes all required transformations.</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void onDrawEye(Eye eye) &#123;</span><br><span class="line">  GLES20.glEnable(GLES20.GL_DEPTH_TEST);</span><br><span class="line">  GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">  checkGLError(&quot;colorParam&quot;);</span><br><span class="line"></span><br><span class="line">  // Apply the eye transformation to the camera.</span><br><span class="line">  Matrix.multiplyMM(view, 0, eye.getEyeView(), 0, camera, 0);</span><br><span class="line"></span><br><span class="line">  // Set the position of the light</span><br><span class="line">  Matrix.multiplyMV(lightPosInEyeSpace, 0, view, 0, LIGHT_POS_IN_WORLD_SPACE, 0);</span><br><span class="line"></span><br><span class="line">  // Build the ModelView and ModelViewProjection matrices</span><br><span class="line">  // for calculating cube position and light.</span><br><span class="line">  float[] perspective = eye.getPerspective(Z_NEAR, Z_FAR);</span><br><span class="line">  Matrix.multiplyMM(modelView, 0, view, 0, modelCube, 0);</span><br><span class="line">  Matrix.multiplyMM(modelViewProjection, 0, perspective, 0, modelView, 0);</span><br><span class="line">  drawCube();</span><br><span class="line"></span><br><span class="line">  // Set modelView for the floor, so we draw floor in the correct location</span><br><span class="line">  Matrix.multiplyMM(modelView, 0, view, 0, modelFloor, 0);</span><br><span class="line">  Matrix.multiplyMM(modelViewProjection, 0, perspective, 0, modelView, 0);</span><br><span class="line">  drawFloor();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Google VR 实现左右眼视觉变形操作。</p>
</li>
<li><p>响应</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * Called when the Cardboard trigger is pulled.cardboard上的按钮，或者是屏幕点击事件都可以触发</span><br><span class="line">  */</span><br><span class="line"> @Override</span><br><span class="line"> public void onCardboardTrigger() &#123;</span><br><span class="line">   Log.i(TAG, &quot;onCardboardTrigger&quot;);</span><br><span class="line"></span><br><span class="line">   if (isLookingAtObject()) &#123;如果目标物体在视觉范围内，则</span><br><span class="line">     successSourceId = gvrAudioEngine.createStereoSound(SUCCESS_SOUND_FILE);</span><br><span class="line">     gvrAudioEngine.playSound(successSourceId, false /* looping disabled */);</span><br><span class="line">     hideObject();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Always give user feedback.</span><br><span class="line">   vibrator.vibrate(50);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>音频</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gvrAudioEngine =</span><br><span class="line">    new GvrAudioEngine(this, GvrAudioEngine.RenderingMode.BINAURAL_HIGH_QUALITY);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>demo主要展示了GvrActivity，GvrView, GvrAudioEngine d的几个基本用法，SDK主要提供了左右眼形变后产生立体效果的这部分功能，已经声音引擎对应的使用，以及头部位置信息动作的封装。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/02/25/android vr and ar/">Android vr ar</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-25
        </span><span class="post-category">
            <a href="/categories/ANDROID/">ANDROID</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h1 id="Android-VR-AR"><a href="#Android-VR-AR" class="headerlink" title="Android VR-AR"></a>Android VR-AR</h1><p>如果接下来要做AR眼镜相关的项目，目前需要做一些知识储备。所以本文做为一个项目开始前的准备工作。了解目前已知行业先行者已经实现的技术是已经到了一个什么样的程度后，才知道我们要前进的方向。着重了解Google和目前接触到的一个比较完善的vr-ar系统公司睿悦Niburu。</p>
<h2 id="VR和AR的概念"><a href="#VR和AR的概念" class="headerlink" title="VR和AR的概念"></a>VR和AR的概念</h2><p>VR(Vritual Reality)虚拟现实，最直白的说就是纯虚拟的数字画面。理解起来就是，用户在VR中看到的所有东西都是虚拟的，但是这些虚拟的东西又需要让用户感觉到很真实。</p>
<p>AR(Argumented Reality)增强现实，虚拟数字画面+裸眼现实</p>
<p>此外现在还有一个概念提出来，MR(Mediatd Reality)介导现实，数字化现实+虚拟数字画面</p>
<ul>
<li><p>VR和AR的关系，可以理解为，VR为AR的一种极端情况。即假设我们把人眼的内容分为现实中真实的部分+数字投放的Argumentation（增强）部分。那么如果这种虚拟的部分越来越多以至于一种极端的情况，几乎没有的真实的部分，这种情况下叫：VR。所以这样理解起来，VR是AR的一个真子集。虚拟的东西占了全部，以至于越来越偏离了原来的现实原点。</p>
</li>
<li><p>MR 数字化的视觉感知。对本身现实的感知能力的大小。例如让你有能力看到更小的东西，例如让佩戴者像有了X射线般的超级视力，看到皮肤下的血管？？？超能力！！或者是在现实的景物傻姑娘加以渲染，置身奇幻世界等等。所以MR是视觉能力维度上的提升。</p>
<p><img src="https://pic3.zhimg.com/80/817549fc583ef153904ef2f324e3fa0f_hd.jpg" alt="知乎图示"></p>
<p>他们三者的关系像是：在AR之外，增加了数字化的感知能力。</p>
<p><img src="https://pic4.zhimg.com/80/f208e8d885ed7749c9b1c53988f85593_hd.jpg" alt="知乎图示"></p>
</li>
</ul>
<blockquote>
<p>以上整理自36kr，作者艾韬，易瞳科技CTO，师从Steve Mann。</p>
</blockquote>
<p>为什么不是同心圆，而是有偏离呢？全图其实还有：</p>
<p><img src="http://a.36krcnd.com/nil_class/6d8fab32-010b-4d77-bf31-20af3eb0358e/7B22.tmp.jpg!heading" alt></p>
<p>还有个Mixed，混合现实。如果我们把同心圆的原点认为是真实世界的原点。这几个概念给我们的感受是怎样的？</p>
<h2 id="市面上的AR-VR眼镜"><a href="#市面上的AR-VR眼镜" class="headerlink" title="市面上的AR-VR眼镜"></a>市面上的AR-VR眼镜</h2><ul>
<li>轻量级AR - Google Glass，单眼棱镜光学透视的设计方案，提示型系统</li>
<li>中量级AR - Hololens，双目棱镜光学透视方案，还有例如亮风台</li>
<li>重量级AR - HTC the Void 动态VR 眼镜，头戴VR显示，背上电脑，将真实的环境渲染成游戏场景。</li>
<li>纯VR - VR头盔</li>
</ul>
<h2 id="Google-VR-做了什么"><a href="#Google-VR-做了什么" class="headerlink" title="Google VR 做了什么"></a>Google VR 做了什么</h2><ul>
<li><p>DayDream</p>
<blockquote>
<p>Daydream是由谷歌2016年11月10日发布的一个vr平台，由一个头盔，一个控制杆盒很多兼容的智能手机组成。</p>
</blockquote>
<p><img src="http://7xl98n.com1.z0.glb.clouddn.com/QQ20180225-151253@2x.png" alt></p>
<p>我们可以使用google提供的VR SDK来开发Daydream app</p>
<ul>
<li><p>硬件</p>
<p>Daydream 或者 cardboard</p>
<p><img src="http://7xl98n.com1.z0.glb.clouddn.com/QQ20180225-153056@2x.png" alt></p>
</li>
<li><p>软件</p>
<p>android studio，Nougat（API 25）or higher, Google VR SDK</p>
</li>
<li><p>VR SDK sample</p>
<p>sdk-treasurehunt：示例应用，可以展示搜索和搜集物品。</p>
<p>sdk-controllerclient     主要演示接收和处理daydream的控制输入</p>
<p>sdk-simplepanowidget     可以载入全景视图的组件<br>sdk-simplevideowidget     可以渲染360度视频的视图组件 VRView<br>sdk-video360     可以渲染360度视频的视图组件，在可支持的手机上运行vr效果的播放器时候，<strong>屏幕会闪烁</strong><br>sdk-videoplayer     通过 Asynchronous Reprojection Video Surface API来播放视频，</p>
</li>
<li><p>Treasure Hunt 示例应用演练</p>
<p>这个应用体现的Google VR SDK的核心功能：<strong>Stereo rendering</strong> 立体渲染，将app的view进行立体渲染，从而创造出3D的体验；<strong>Spatial audio</strong> 空间音效，制造出声音从不同地方出来的效果，增强现实体验；<strong>Head movement tracking</strong>根据头部动作，更新视图；<strong>User input</strong>用户输入响应，接收Daydream controller或者Cardboard 按钮的输入。</p>
<p><em>Todo: <a href="https://developers.google.com/vr/android/samples/treasure-hunt" target="_blank" rel="noopener">Treasure Hunt walkthrough</a> 详细走一遍sample的代码</em> </p>
</li>
<li><p>开发GoogleVR项目步骤</p>
<ol>
<li><p>配置项目等级</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// The Google VR SDK requires version 2.3.3 or higher.</span><br><span class="line">    classpath &apos;com.android.tools.build:gradle:2.3.3&apos;</span><br><span class="line"></span><br><span class="line">    // The Google VR NDK requires experimental version 0.9.3 or higher.</span><br><span class="line">    // classpath &apos;com.android.tools.build:gradle-experimental:0.9.3&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加依赖库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">     // Adds Google VR spatial audio support</span><br><span class="line">     compile &apos;com.google.vr:sdk-audio:1.80.0&apos;</span><br><span class="line"></span><br><span class="line">     // Required for all Google VR apps</span><br><span class="line">     compile &apos;com.google.vr:sdk-base:1.80.0&apos;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置ProGuard</p>
<p>如果需要使用proguard来减小apk文件大小的话，需要添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled true</span><br><span class="line">            proguardFiles.add(file(&apos;../../proguard-gvr.txt&apos;))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来需要哪些知识储备：</p>
<ul>
<li><p>浏览一遍谷歌VR示例代码 Treasure Hunt，寻宝游戏</p>
</li>
<li><p>GoogleVRSDK视频和全景图片示例应用</p>
</li>
<li><p>GoogleVR设计和开发准则</p>
</li>
<li><p>android空间音频效果开发向导</p>
</li>
<li><p>Google VR API</p>
</li>
<li><p>Daydream，学习Daydream用户交互控制器相关操作，可查看Review the controller library in <strong>gvr-android-sdk</strong> &gt; <strong>libraries</strong> &gt;<br>  <strong>sdk-controller</strong> ，查阅 库api 控制器 API</p>
<blockquote>
<p>原文链接如下：</p>
</blockquote>
</li>
<li><p><a href="https://developers.google.com/vr/android/samples/treasure-hunt" target="_blank" rel="noopener">Treasure Hunt sample code walkthrough</a></p>
</li>
<li><p><a href="https://developers.google.com/vr/android/samples/vrview" target="_blank" rel="noopener">Google VR SDK video and panoramic image sample app walkthrough</a></p>
</li>
<li><p>Learn about Google VR design and development principles in <a href="https://developers.google.com/vr/elements/overview" target="_blank" rel="noopener">Daydream elements</a>.</p>
</li>
<li><p><a href="https://developers.google.com/vr/android/spatial-audio" target="_blank" rel="noopener">Spatial audio for Android tutorial</a></p>
</li>
<li><p><a href="https://developers.google.com/vr/android/reference_overview" target="_blank" rel="noopener">Google VR API Reference</a></p>
</li>
<li><p>Daydream:</p>
<p> Learn about implementing Daydream controller user interactions   in your app:</p>
<ul>
<li>Review the controller library in <strong>gvr-android-sdk</strong> &gt; <strong>libraries</strong> &gt;  <strong>sdk-controller</strong>.</li>
<li>See also the <a href="https://developers.google.com/vr/android/reference/com/google/vr/sdk/controller/package-summary" target="_blank" rel="noopener">controller library API reference</a>.</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Tilt Brush</p>
<p>3d空间绘画</p>
<p>Oculus Rift and HTC VIVE可支持该功能。</p>
<p>都是vr头戴式设备</p>
<p>​</p>
</li>
<li><p>Earth VR</p>
<p>vr 视角来查看一些风景名胜</p>
</li>
<li><p>Cardboard</p>
</li>
<li><p>Expeditions</p>
<p>教育类相关，旅行远征，例如体验在火星表面，老师可以带着孩子进行更有沉浸式的体验</p>
</li>
<li><p>Jump</p>
<p>Jump is Google’s professional VR video solution. Jump makes 3D-360 video<br> production at scale possible with best-in-class automated stitching.<br>Jump cameras are designed to work with the Jump Assembler to enable<br>seamless VR video production.</p>
<p>一系列的摄像头产品，用于拍摄全景视频，自动缝合技术，实现</p>
</li>
<li><p>Developers</p>
</li>
</ul>
<h2 id="Google-AR-提供了什么"><a href="#Google-AR-提供了什么" class="headerlink" title="Google AR 提供了什么"></a>Google AR 提供了什么</h2><p><a href="https://developers.google.com/ar/discover/" target="_blank" rel="noopener">https://developers.google.com/ar/discover/</a></p>
<p>ARCore 是一个用于在 Android 上构建增强现实应用的平台。ARCore 使用三个主要技术将虚拟内容与通过手机摄像头看到的现实世界整合：</p>
<ul>
<li><a href="https://developers.google.com/ar/discover/concepts#motion_tracking" target="_blank" rel="noopener"><strong>运动跟踪</strong></a>让手机可以理解和跟踪它相对于现实世界的位置。</li>
<li><a href="https://developers.google.com/ar/discover/concepts#environmental_understanding" target="_blank" rel="noopener"><strong>环境理解</strong></a>让手机可以检测平坦水平表面（例如地面或咖啡桌）的大小和位置。</li>
<li><a href="https://developers.google.com/ar/discover/concepts#light_estimation" target="_blank" rel="noopener"><strong>光估测</strong></a>让手机可以估测环境当前的光照条件。</li>
</ul>
<h3 id="ARCore基本工作原理"><a href="#ARCore基本工作原理" class="headerlink" title="ARCore基本工作原理"></a>ARCore基本工作原理</h3><blockquote>
<p>ARCore 在做两件事：在移动设备移动时跟踪它的位置和构建自己对现实世界的理解。</p>
<p>ARCore 的运动跟踪技术使用手机摄像头标识兴趣点（称为特征点），并跟踪这些点随着时间变化的移动。将这些点的移动与手机惯性传感器的读数组合，ARCore 可以在手机移动时确定它的位置和屏幕方向。</p>
<p>除了标识关键点外，ARCore 还会检测平坦的表面（例如桌子或地面），并估测周围区域的平均光照强度。 这些功能共同让 ARCore 可以构建自己对周围世界的理解。</p>
<p>借助 ARCore 对现实世界的理解，您能够以一种与现实世界无缝整合的方式添加物体、注释或其他信息。 您可以将一只打盹的小猫放在咖啡桌的一角，或者利用艺术家的生平信息为一幅画添加注释。 运动跟踪意味着您可以移动和从任意角度查看这些物体，即使您转身离开房间，当您回来后，小猫或注释还会在您添加的地方。</p>
</blockquote>
<h3 id="Arcore-SDK概览"><a href="#Arcore-SDK概览" class="headerlink" title="Arcore SDK概览"></a>Arcore SDK概览</h3><h4 id="Hello-AR-java"><a href="#Hello-AR-java" class="headerlink" title="Hello AR java"></a>Hello AR java</h4><p>需要android 7.0以上，需要安装arcore</p>
<ul>
<li><p>清单文件，声明需要android.hardware.camera.ar，且需要安装Arcore，文件表明应用在Google的应用市场上只能在支持arcore的设备上可见</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    package=&quot;com.google.ar.core.examples.java.helloar&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt;</span><br><span class="line">  &lt;!-- This tag indicates that this application requires ARCore.  This results in the application</span><br><span class="line">       only being visible in the Google Play Store on devices that support ARCore. --&gt;</span><br><span class="line">  &lt;uses-feature android:name=&quot;android.hardware.camera.ar&quot; android:required=&quot;true&quot;/&gt;</span><br><span class="line"></span><br><span class="line">  &lt;application</span><br><span class="line">      android:allowBackup=&quot;false&quot;</span><br><span class="line">      android:icon=&quot;@drawable/ic_launcher&quot;</span><br><span class="line">      android:label=&quot;@string/app_name&quot;</span><br><span class="line">      android:theme=&quot;@style/AppTheme&quot;</span><br><span class="line">      android:usesCleartextTraffic=&quot;false&quot;</span><br><span class="line">      tools:ignore=&quot;GoogleAppIndexingWarning&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;activity</span><br><span class="line">        android:name=&quot;.HelloArActivity&quot;</span><br><span class="line">        android:label=&quot;@string/app_name&quot;</span><br><span class="line">        android:configChanges=&quot;orientation|screenSize&quot;</span><br><span class="line">        android:exported=&quot;true&quot;</span><br><span class="line">        android:theme=&quot;@style/Theme.AppCompat.NoActionBar&quot;</span><br><span class="line">        android:screenOrientation=&quot;locked&quot;&gt;</span><br><span class="line">      &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;</span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;</span><br><span class="line">      &lt;/intent-filter&gt;</span><br><span class="line">    &lt;/activity&gt;</span><br><span class="line">    &lt;!-- 需要安装arcore --&gt;</span><br><span class="line">    &lt;meta-data android:name=&quot;com.google.ar.core&quot; android:value=&quot;required&quot; /&gt;</span><br><span class="line">  &lt;/application&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="computevision"><a href="#computevision" class="headerlink" title="computevision"></a>computevision</h4><ul>
<li><p>清单文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    package=&quot;com.google.ar.core.examples.java.computervision&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot;/&gt;</span><br><span class="line"></span><br><span class="line">  &lt;application</span><br><span class="line">      android:allowBackup=&quot;false&quot;</span><br><span class="line">      android:icon=&quot;@drawable/ic_launcher&quot;</span><br><span class="line">      android:label=&quot;@string/app_name&quot;</span><br><span class="line">      android:theme=&quot;@style/AppTheme&quot;</span><br><span class="line">      android:usesCleartextTraffic=&quot;false&quot;</span><br><span class="line">      tools:ignore=&quot;GoogleAppIndexingWarning&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;activity</span><br><span class="line">        android:name=&quot;.MainActivity&quot;</span><br><span class="line">        android:label=&quot;@string/app_name&quot;</span><br><span class="line">        android:configChanges=&quot;orientation|screenSize&quot;</span><br><span class="line">        android:exported=&quot;true&quot;</span><br><span class="line">        android:theme=&quot;@style/Theme.AppCompat.NoActionBar&quot;</span><br><span class="line">        android:screenOrientation=&quot;locked&quot;&gt;</span><br><span class="line">      &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;</span><br><span class="line">        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;</span><br><span class="line">      &lt;/intent-filter&gt;</span><br><span class="line">    &lt;/activity&gt;</span><br><span class="line">  &lt;/application&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>TODO: ARdemo walkthrough</p>
</blockquote>
<p>Api 查阅</p>
<ul>
<li><a href="https://developers.google.com/ar/reference/java/com/google/ar/core/package-summary" target="_blank" rel="noopener">com.google.ar.core</a> ARCore API implementation.</li>
<li><a href="https://developers.google.com/ar/reference/java/com/google/ar/core/exceptions/package-summary" target="_blank" rel="noopener">com.google.ar.core.exceptions</a> ARCore exceptions.</li>
</ul>
<h3 id="如何启用ARCore"><a href="#如何启用ARCore" class="headerlink" title="如何启用ARCore"></a>如何启用ARCore</h3><h4 id="清单文件配置"><a href="#清单文件配置" class="headerlink" title="清单文件配置"></a>清单文件配置</h4><ul>
<li><p>AR only: 以下定义表示应用只能在支持android.hardware.camera.ar，且安装了com.google.ar.core的设备上运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-sdk android:minSdkVersion=&quot;&#123;24 or higher&#125;&quot; /&gt;</span><br><span class="line">24以上版本</span><br><span class="line">  ...</span><br><span class="line">  &lt;uses-feature android:name=&quot;android.hardware.camera.ar&quot; android:required=&quot;true&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;application&gt;</span><br><span class="line">    ...</span><br><span class="line">        &lt;meta-data android:name=&quot;com.google.ar.core&quot; android:value=&quot;required&quot; /&gt;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>AR可选，表示可以在不支持AR Core的设备上运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-sdk android:minSdkVersion=&quot;&#123;14 or higher&#125;&quot; /&gt;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  &lt;application&gt;</span><br><span class="line">    ...</span><br><span class="line">        &lt;meta-data android:name=&quot;com.google.ar.core&quot; android:value=&quot;optional&quot; /&gt;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>确认已经在项目的  <code>build.gradle</code> 文件中添加了 Google’s Maven 仓库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">repositories &#123;</span><br><span class="line">    google()</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>添加 ARCore 库依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    // ARCore library</span><br><span class="line">    implementation &apos;com.google.ar:core:1.0.0&apos;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Gradle会自动的将ARcore中的标签合并到应用的清单文件中。</p>
</blockquote>
<h4 id="执行运行时检查"><a href="#执行运行时检查" class="headerlink" title="执行运行时检查"></a>执行运行时检查</h4><p>确认是否已安装ARcore</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// Set to true ensures requestInstall() triggers installation if necessary.</span><br><span class="line">private boolean mUserRequestedInstall = true;</span><br><span class="line"></span><br><span class="line">// in onResume:</span><br><span class="line">try &#123;</span><br><span class="line">  if (mSession == null) &#123;</span><br><span class="line">    switch (ArCoreApk.getInstance().requestInstall(this, mUserRequestedInstall)) &#123;</span><br><span class="line">      case INSTALLED:</span><br><span class="line">        mSession = new Session(this);</span><br><span class="line">        // Success.</span><br><span class="line">        break;</span><br><span class="line">      case INSTALL_REQUESTED:</span><br><span class="line">        // Ensures next invocation of requestInstall() will either return</span><br><span class="line">        // INSTALLED or throw an exception.</span><br><span class="line">        mUserRequestedInstall = false;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; catch (UnavailableUserDeclinedInstallException e) &#123;</span><br><span class="line">  // Display an appropriate message to the user and return gracefully.</span><br><span class="line">  return;</span><br><span class="line">&#125; catch (...) &#123;  // current catch statements</span><br><span class="line">  ...</span><br><span class="line">  return;  // mSession is still null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Activity resume的时候，执行session创建，如果创建不成功，则请求安装，</p>
<p>检查是否支持AR core，可选方案的时候</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void maybeEnableArButton() &#123;</span><br><span class="line">  // Likely called from Activity.onCreate() of an activity with AR buttons.</span><br><span class="line">  ArAvailability availability = ArCoreApk.getInstance().checkAvailability(this);</span><br><span class="line">  if (availability.isTransient()) &#123;</span><br><span class="line">    // re-query at 5Hz while we check compatibility.</span><br><span class="line">    new Handler().postDelayed(new Runnable() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">        maybeEnableArButton();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 200);</span><br><span class="line">  &#125;</span><br><span class="line">  if (availability.isSupported()) &#123;</span><br><span class="line">    mArButton.setVisibility(VISIBLE);</span><br><span class="line">    mArButton.setEnabled(true);</span><br><span class="line">    // indicator on the button.</span><br><span class="line">  &#125; else &#123; // unsupported or unknown</span><br><span class="line">    mArButton.setVisibility(HIDDEN);</span><br><span class="line">    mArButton.setEnabled(false);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>checkAvailability可能需要联网检查</p>
</blockquote>
<h2 id="Google-VR-AR-在现有平台上的运行情况"><a href="#Google-VR-AR-在现有平台上的运行情况" class="headerlink" title="Google VR AR 在现有平台上的运行情况"></a>Google VR AR 在现有平台上的运行情况</h2><ol>
<li><p>寻宝游戏，demo 代码根据vr提供的sdk实现了左右分屏的这种效果，也就是说只要运行在普通的安卓手机上，在屏幕上，就可以看到一个左右分屏显示的功能，然后如果配合Google 的cardboard viewer 或者是 Daydream viewer 是可以直接在眼睛上实现3D显示的。那这个demo在我们的820+眼镜上的运行效果就是。在切换到2D模式的时候，我们看到的就是两个左右的图片，切换到3d的时候，确实可以实现看到一个叠加的图片，但是这个叠加后的有些变形。</p>
</li>
<li><p>Google vr播放器，需要在7.0以上版本运行，2d的播放器可以在5516上运行，但要切换成3D模式的时候，提示手机与Daydream不兼容；在pixel一些指定的兼容设备上才可运行，但是运行起来感觉屏幕闪烁较为明显，需要配合daydream屏体的控制器运行观看</p>
</li>
<li><p>ARcore支持的设备：</p>
<blockquote>
<p>Asus Zenfone AR</p>
<p>LG V30</p>
<p>Google Pixel</p>
<p>OnePlus 5</p>
<p>Samsung Galaxy</p>
</blockquote>
<p>在可支持的设备上，<strong>hello ar</strong>运行的起来就是一个摄像头应用，在识别平坦桌面后，可以放置android玩偶，然后移动相机，可以实现，各种视角查看玩偶。就想真实存在的物体一样。</p>
<p>5516无法支持ARcore</p>
<p><strong>computevision</strong> 纹理阅读，可识别物体纹理</p>
</li>
</ol>
<h2 id="如何兼容Google-VR-AR"><a href="#如何兼容Google-VR-AR" class="headerlink" title="如何兼容Google VR AR"></a>如何兼容Google VR AR</h2><ul>
<li><p>VR、 Daydream</p>
<p><uses-feature android:name="android.software.vr.mode" android:required="false">和<uses-feature android:name="android.hardware.vr.high_performance" android:required="false"> 由 Android N加入的新特性，前者表示需要使用Android VR模式，后者表示需要可支持Daydream的设备。</uses-feature></uses-feature></p>
<p>对于没有Google VR服务的设备，需要安装Google VR 服务，才可以将可支持Daydream的设备与对应的VR viewer配对</p>
</li>
</ul>
<ul>
<li><p>AR</p>
 <uses-feature android:name="android.hardware.camera.ar" android:required="true">

<p>另外需要安装ARcore</p>
</uses-feature></li>
</ul>
<h2 id="Nibiru-系统"><a href="#Nibiru-系统" class="headerlink" title="Nibiru 系统"></a>Nibiru 系统</h2><h2 id="Nibiru-VR"><a href="#Nibiru-VR" class="headerlink" title="Nibiru VR"></a>Nibiru VR</h2><ul>
<li><p>Nibiru studio</p>
<blockquote>
<p>面向VR应用开发者，开发者无需OpenGL基础，无需写<br>shader和计算矩阵，极大地简化了VR应用开发流程。并且<br>支持Head Tracking和Raycast交互方式，以及具有完善的<br>事件系统。定义了功能丰富的VR控件与组件集合，在功能点<br>上涵盖了Image、Label、Skybox、Listview、<br>ProgressBar Gridview等核心控件，同时支持播放、图片、<br>浏览器等组件。</p>
</blockquote>
</li>
<li><p>demo运行</p>
<p>新建一个空的项目，选择 file-new-import module，选择模块源码位置，点击finish，完成倒入</p>
<p>需要睿悦的os。</p>
<p>demo展示的主要展示了基于睿悦系统的一些基本控件的使用，基于睿悦系统的头部运动操作和响应，以及对系统设置Wi-Fi、蓝牙等系统界面的调用。</p>
<p>整体体验起来，空间立体的感觉还不够，似乎只是一个2d界面，经过3d左右分屏处理后，融合sensor之后的附加的交互而已。立体渲染部分比较少，给人的空间感体验较差。</p>
</li>
</ul>
<h2 id="Nibiru-AR"><a href="#Nibiru-AR" class="headerlink" title="Nibiru AR"></a>Nibiru AR</h2><p>目前就demo而言，AR的特性体现的比较少。</p>
<h2 id="Unity"><a href="#Unity" class="headerlink" title="Unity"></a>Unity</h2><p>游戏与VR/AR开发引擎。</p>
<h2 id="Unreal"><a href="#Unreal" class="headerlink" title="Unreal"></a>Unreal</h2><p><a href="https://www.zhihu.com/question/20116279" target="_blank" rel="noopener">https://www.zhihu.com/question/20116279</a> 知乎上关于unity和unreal两个平台的对比</p>
<p>TODO: 体验一下</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/02/21/bookxiaobai application/">书小白书单功能实现</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-02-21
        </span><span class="post-category">
            <a href="/categories/ANDROID/">ANDROID</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p>书小白书单功能实现</p>
          <div class="read-more">
            <a href="/2018/02/21/bookxiaobai application/" class="read-more-link">阅读更多</a>
          </div>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2017/12/11/android private so/">Android N  无法调用私有库问题</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2017-12-11
        </span><span class="post-category">
            <a href="/categories/ANDROID/">ANDROID</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h1 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h1><p>因项目需要，需要将一个第三方的应用集成到系统平台上，这个第三方应用带有自己的私有so库和jni代码等。按照以前的集成方式，</p>
<pre><code>LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)

LOCAL_MODULE_TAGS := optional

LOCAL_TARGET_CPU_ABI := $(TARGET_CPU_ABI)
LOCAL_MULTILIB := 32

ifeq ($(TARGET_CPU_ABI), arm64-v8a)
    LOCAL_MULTILIB := 64
else
    ifeq ($(TARGET_CPU_ABI), armeabi-v7a)
        LOCAL_TARGET_CPU_ABI := armeabi
    endif
endif

LOCAL_PREBUILT_LIBS  :=    \
    libs/$(LOCAL_TARGET_CPU_ABI)/xxx.so 

include $(BUILD_MULTI_PREBUILT)</code></pre><p>按照以上MK方式集成后，发现如下错：</p>
<pre><code>01-01 09:18:59.348  4092  4092 E AndroidRuntime: FATAL EXCEPTION: main
01-01 09:18:59.348  4092  4092 E AndroidRuntime: Process: com.olc.magicuhf, PID: 4092
01-01 09:18:59.348  4092  4092 E AndroidRuntime: java.lang.UnsatisfiedLinkError: dlopen failed: library &quot;/system/lib64/libuhf-tools.so&quot; needed or dlopened by &quot;/system/lib64/libnativeloader.so&quot; is not accessible for the namespace &quot;classloader-namespace&quot;
01-01 09:18:59.348  4092  4092 E AndroidRuntime:     at java.lang.Runtime.loadLibrary0(Runtime.java:989)
01-01 09:18:59.348  4092  4092 E AndroidRuntime:     at java.lang.System.loadLibrary(System.java:1562)
01-01 09:18:59.348  4092  4092 E AndroidRuntime:     at android.hardware.uhf.magic.Reader.&lt;clinit&gt;(Reader.java:1279)
01-01 09:18:59.348  4092  4092 E AndroidRuntime:     at android.hardware.uhf.magic.Reader.init(Native Method)
01-01 09:18:59.348  4092  4092 E AndroidRuntime:     at com.olc.magicuhf.App.InitUHF(App.java:22)
01-01 09:18:59.348  4092  4092 E AndroidRuntime:     at com.olc.magicuhf.App.onCreate(App.java:18)
01-01 09:18:59.348  4092  4092 E AndroidRuntime:     at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1025)
01-01 09:18:59.348  4092  4092 E AndroidRuntime:     at android.app.ActivityThread.handleBindApplication(ActivityThread.java:5405)
01-01 09:18:59.348  4092  4092 E AndroidRuntime:     at android.app.ActivityThread.-wrap2(ActivityThread.java)
01-01 09:18:59.348  4092  4092 E AndroidRuntime:     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1546)
01-01 09:18:59.348  4092  4092 E AndroidRuntime:     at android.os.Handler.dispatchMessage(Handler.java:102)
01-01 09:18:59.348  4092  4092 E AndroidRuntime:     at android.os.Looper.loop(Looper.java:154)
01-01 09:18:59.348  4092  4092 E AndroidRuntime:     at android.app.ActivityThread.main(ActivityThread.java:6121)
01-01 09:18:59.348  4092  4092 E AndroidRuntime:     at java.lang.reflect.Method.invoke(Native Method)
01-01 09:18:59.348  4092  4092 E AndroidRuntime:     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:889)
01-01 09:18:59.348  4092  4092 E AndroidRuntime:     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:779)
01-01 09:18:59.351  1342  1816 W ActivityManager:   Force finishing activity com.olc.magicuhf/.MainActivity</code></pre><h1 id="方式一：NO"><a href="#方式一：NO" class="headerlink" title="方式一：NO"></a>方式一：NO</h1><p>查了一些资料说：ndroid N 不能直接调用系统的一些私有库了，公用的库都定义在public.libraries.txt里面系统应用刚刷机是能够调用system/lib64下的库，但通过install升级该应用时，应用打开会挂。因为升级后permitted_paths就不再包含system/lib64了。所以我们可以将apk要用到的库名称写到public.libraries.txt中去解决快速调试问题。</p>
<p>尝试了这种方法，引发更多的编译错误，惹不起，惹不起。</p>
<h1 id="方式二：yes"><a href="#方式二：yes" class="headerlink" title="方式二：yes"></a>方式二：yes</h1><p>之前都是讲这些SO库集成编译到系统里面，现在需要so库编译到apk中，这样就不是系统的私有库了，是apk自带的库。重点如下</p>
<pre><code>LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)
LOCAL_STATIC_JAVA_LIBRARIES := android-support-v4
LOCAL_MODULE_TAGS := optional
LOCAL_SRC_FILES := \
$(call all-java-files-under, src)
LOCAL_PACKAGE_NAME := Demo
LOCAL_CERTIFICATE := platform
LOCAL_PROGUARD_FLAG_FILES := proguard.flags
#LOCAL_PROGUARD_ENABLED :=full
LOCAL_PRIVILEGED_MODULE := false
LOCAL_JNI_SHARED_LIBRARIES := libfingerprint
LOCAL_MODULE_INCLUDE_LIBRARY  := true
LOCAL_PREBUILT_JNI_LIBS := jni/xxx.so
$(shell cp -rf $(LOCAL_PATH)/jni/xx.so $(TARGET_OUT)/lib64/xxx.so)

# := proguard.flagLOCAL_PROGUARD_FLAG_FILESs

LOCAL_AAPT_FLAGS += -c zz_ZZ

include $(BUILD_PACKAGE)

include $(call all-makefiles-under, jni)

# Use the folloing include to make our test apk.
include $(call all-makefiles-under,$(LOCAL_PATH))</code></pre><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>1.如果需要访问系统文件节点，则需要系统权限，且uid要为android:sharedUserId=”android.uid.system”才可以访问。<br>具体和SELinux的权限设置有关，除非改对应的te文件，不然，根据权限设置，必须系统应用而且UID也需要是系统的才可以访问。</p>
<p>2.so库需要打包到应用中才可以调用，Android N之后，非系统应用无法调用系统私有库。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2016/08/18/android performance part3/">Android performance par3: Memory</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-08-18
        </span><span class="post-category">
            <a href="/categories/ANDROID/">ANDROID</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h1 id="关于内存的一些小tips"><a href="#关于内存的一些小tips" class="headerlink" title="关于内存的一些小tips"></a>关于内存的一些小tips</h1><ol>
<li>Android 的每个应用程序都会使用一个专有的Dalvik虚拟机实例来运行，每个应用程序都是在属于自己的进程中运行的。</li>
<li>如果程序在运行过程中出现了内存泄漏的问题，仅仅会使得自己的进程被杀掉，而不会影响其他进程（如果是system_process 等系统进程出问题的话，则会引起系统重启）。</li>
<li>Android为不同类型的进程分配了不同的内存使用上限，如果应用进程使用的内存超过了这个上限， 则会被系统视为内存泄漏，从而被杀掉Android会根据进程中运行的组件类别以及组件的状态来判断该进程的重要性，从高到低一共有五个级别：前台进程、可见进程、服务进程、后台进程、空进程。</li>
<li>Android设备出厂以后，java虚拟机对单个应用的最大内存分配就确定下来了，超出这个值就会OOM。这个属性值是定义在/system/build.prop文件中的 dalvik.vm.heapsize=36m</li>
<li>当GC发生时，虚拟机会从GC Roots 开始去扫描当前的对象树，发现通过任何reference chain(引用链)无法访问某个对象的时候，该对象即被回收</li>
<li>Java中包含4种对象引用：强引用、软引用、弱引用、虚引用</li>
<li>Shallow size就是对象本身占用内存的大小，不包含对其他对象的引用，也就是对象头加成员变量（不是成员变量的值）的总和</li>
<li>Retained size是该对象自己的shallow size，加上只能从该对象能直接或间接访问到对象的shallow size之和</li>
</ol>
<h1 id="Memory-monitor"><a href="#Memory-monitor" class="headerlink" title="Memory monitor"></a>Memory monitor</h1><ol>
<li>发现内存抖动的场景 </li>
<li>发现大内存对象分配的场景 </li>
<li>发现内存不断增长的场景 </li>
<li>确定卡顿问题是否因为执行了GC操作</li>
</ol>
<h1 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h1><p>之前我们知道Android的应用程序所能申请的最大内存都是有限的，OOM是指APP向系统申请内存的请求超过了应用所能有的最大阀值的内存，系统无法再分配多余的空间，就会造成OOM error。</p>
<p>在Android平台下，除了之前所说的持续发生了内存泄漏(Memory Leak)</p>
<p>一次性申请很多内存，比如说一次创建大的数组或者是载入大的文件如图片的时候</p>
<h1 id="Leakcanary"><a href="#Leakcanary" class="headerlink" title="Leakcanary"></a>Leakcanary</h1><p>关于Leakcanary 工具可参考之前的文章。</p>
<h1 id="内存优化总结"><a href="#内存优化总结" class="headerlink" title="内存优化总结"></a>内存优化总结</h1><ul>
<li><p>static：static声明变量的生命周期其实是和APP的生命周期一 样的，请合理使用。无关引用：比如比较有代表性的Context泄漏，很多情况下当Activity 结束掉后，由于仍被其他的对象指向导致一直迟迟不能回收，这就造成了内存泄漏</p>
</li>
<li><p>SoftReference/WeakReference/LruCache：如果对内存的开销比较关注的APP，可以考虑使用WeakReference，当GC回收扫过这块内存区域时 就会回收；如果不是那么关注的话，可以使用SoftReference，它会在内存申请不足的情况下自动释放，同样也能解决OOM问题</p>
</li>
<li><p>谨慎handler：handler运行于UI 线程，不断处理来自MessageQueue的消息，如果handler还有消息需要处理但是Activity页面已经结束的情况下，Activity的 引用其实并不会被回收，这就造成了内存泄漏。解决方案，一是在Activity的onDestroy方法中调用handler.removeCallbacksAndMessages(null);取消所有的消息的处理，包括待处理的消息；二是声明handler的内部类为static。</p>
</li>
<li><p>Bitmap：BitmapFactory.Options的inSampleSize属性进行控制，加载网络图片的时候，使用软引用或者弱引用并进 行本地缓存，图片加载的项目 picasso等</p>
</li>
<li><p>Cursor和I/O流及时关闭</p>
</li>
<li><p>ListView和GridView的item缓存</p>
</li>
<li><p>页面背景和图片加载：在布局和代码中设置背景和图片的时候，如果是纯色，尽量使用color；如果是规则图形，尽量使用shape画图；如果稍微复杂点，可以使用9patch图；如果不能使用9patch的情况下，针对几种主流分辨率的机型进行切图。</p>
</li>
<li><p>线程：开启线程数量不易过多，一般和自己机器内核数一样最好。4？</p>
</li>
<li><p>String/StringBuffer</p>
</li>
</ul>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2016/07/08/android performance part2/">Android performance par2: Compute</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-07-08
        </span><span class="post-category">
            <a href="/categories/ANDROID/">ANDROID</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前文主要讲在渲染阶段，我们可以做的优化。本文主要是分析算法对程序运行速度的影响。举个栗子，int的运算速度最快，short次之，byte再次之，long再次之。float和double运算速度最慢；除法比乘法慢的太多，基本上除法是乘法的9倍时间……等等，真的要这么较真吗？？？我只是举个栗子，这说明，我们的代码，实实在在的在影响程序的运行速度。</p>
<p>当然如果我们遇到的只是一个方法耗时太久，那么问题似乎更简单些，我们只需要优化一个方法函数，而整个的运行速度就会有很大的提高。而更麻烦的就是，我们遇到的是，每个方法都慢了一点点，所以我们花了很大的时间，优化了每个方法，但是整体的速度只提高了一点点。</p>
<p><img src="http://7xl98n.com1.z0.glb.clouddn.com/%E5%9B%BE%E7%89%8721.png" alt></p>
<p><img src="http://7xl98n.com1.z0.glb.clouddn.com/%E5%9B%BE%E7%89%8722.png" alt></p>
<h1 id="batching-and-cashing"><a href="#batching-and-cashing" class="headerlink" title="batching and cashing"></a>batching and cashing</h1><p>性能优化中最常用的一项技术就是，批处理和缓存。这可以减少我们进行耗时运算的次数，从而从整体上降低方法的运行时间。</p>
<p>视频举了个斐波那契的数列1,1,2，3，5，8，13，21，34，……数列从第3项起，每一项是前两项的和，这就是有名的斐波拉契数列。</p>
<p>所以计算斐波那契的数列可以用递归的方式来写：</p>
<pre><code>/**
 *  Why store things when you can recurse instead?  Don&apos;t let evidence, personal experience,
 *  or rational arguments from your peers fool you.  The elegant solution is the best solution.
 *
 * @param positionInFibSequence  The position in the fibonacci sequence to return.
 * @return the nth number of the fibonacci sequence.  Seriously, try to keep up.
 */
public int computeFibonacciRecursive(int positionInFibSequence) {
    if (positionInFibSequence &lt;= 2) {
        return 1;
    } else {
        return computeFibonacciRecursive(positionInFibSequence - 1)
                + computeFibonacciRecursive(positionInFibSequence - 2);
    }
}</code></pre><p>似乎看起来没有问题，但实际运行过程中，我们发现随着数列越来越大，递归算法造成的运行时间成指数级的增长。</p>
<p>我抓了两个，分别是数列35 和 数列37 的计算trace文件</p>
<p><img src="http://7xl98n.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170725093716.png?imageView2/2/w/650/h/600/q/75" alt></p>
<p><img src="http://7xl98n.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170725093830.png?imageView2/2/w/650/h/600/q/75" alt></p>
<p>35的时候耗时已经31秒多了，而37时，增加到81秒多。更别提如果是1000的大小的数列。程序的运行时间将达到一个什么级别。</p>
<p>然而在充分理解了函数意义之后，采用算法优化之后，可大大降低运行速度。优化如下：</p>
<pre><code>  /**
 * It is important to understand what your code is doing, no matter how simple the task. For
 * example, most people know better than to compute Fibonacci numbers recursively, but it is
 * not unusual to unintentionally redo work in your application. Check your app for places
 * where you can cache current results for future re-use.
 *
 * In this case, recursive Fibonacci calls fib8 which calls fib7 and fib6, but that fib7 call
 * calls fib6 again and fib5, So now you&apos;ve got two fib6&apos;s and one fib5 call, but each of those
 * fib6 calls will have a fib5 and fib4, so now you have three calls to calculate fib5, blah,
 * blah, blah.  Recursive fibonacci is terrible.  Iterating lets you calculate fibX once,
 * use that result twice, and move on.
 *
 * @param positionInFibSequence  The position in the fibonacci sequence to return.
 * @return the nth number of the fibonacci sequence.  Seriously, try to keep up.
 */
public int computeFibonacci(int positionInFibSequence) {

    int prev = 0;
    int current = 1;
    int newValue;
    for (int i=1; i&lt;positionInFibSequence; i++) {
        newValue = current + prev;
        prev = current;
        current = newValue;
    }

    return current;
}</code></pre><p>将之前的值保存起来，这样，不用每一次都递归去重新计算之前的数列值。</p>
<p>再测试下trace运行速度。</p>
<p><img src="http://7xl98n.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170725094936.png?imageView2/2/w/650/h/600/q/75" alt></p>
<p>计算数列大小为1000的序列值。总共大概三秒。。</p>
<p>这个列子大概演示了，cashing，在程序算法优化上的作用。我们将之前的值cashing起来，而不是再重新计算。大大减少了运算次数。从而将运算性能大大的提高了。</p>
<h2 id="trace-view-的使用"><a href="#trace-view-的使用" class="headerlink" title="trace view 的使用"></a>trace view 的使用</h2><p>找到最耗时的方法，定位性能瓶颈。traceview可以将每个方法的运行时间调用的层级关系清晰的展现出来，方便我们分析。</p>
<p>Android device monitor-&gt;devices-&gt;package name-&gt;        start method profiling-&gt; interact with app -&gt;</p>
<p>使用monitor来获取trace文件，录制了一个动画：</p>
<p><img src="http://7xl98n.com1.z0.glb.clouddn.com/profiling_trace.gif" alt></p>
<p>用代码的方式来获取trace文件</p>
<ol>
<li>Debug的以下静态方法方法来启动： startMethodTracing(String traceName)， stopMethodTracing ()</li>
<li>adb pull /sdcard/XXXX.trace d:XXX.trace</li>
<li>再用DDMS打开trace文件</li>
</ol>
<h1 id="UI-thread"><a href="#UI-thread" class="headerlink" title="UI thread"></a>UI thread</h1><p>应用启动，系统会创建一个主线程（main thread）。这个主线程负责向UI组件分发事件（包括绘制事件）</p>
<ol>
<li>不要阻塞UI线程。</li>
<li>不要在UI线程之外访问Android UI toolkit</li>
</ol>
<p>如果线程被阻塞了，那么我们可能会得到一个ANR：</p>
<p>应用开发中常见的ANR主要有如下几类：</p>
<ul>
<li>按键触摸事件派发超时ANR，一般阈值为5s（设置中开启ANR弹窗，默认有事件派发才会触发弹框ANR）；</li>
<li>广播阻塞ANR，一般阈值为10s（设置中开启ANR弹窗，默认不弹框，只有log提示）；</li>
<li>服务超时ANR，一般阈值为20s（设置中开启ANR弹窗，默认不弹框，只有log提示）；</li>
</ul>
<p>发现ANR的时候可以通过如下命令，查看一些anr的信息，ANR文件的分析，我过个阶段会整理下遇到的问题和解决方式。</p>
<p>adb pull /data/anr/ arn/</p>
<p>为了不要阻塞UI线程，我们需要将耗时的工作放在其他线程中。</p>
<p>这个就不具体举例了。</p>
<h1 id="数据结构对性能的影响"><a href="#数据结构对性能的影响" class="headerlink" title="数据结构对性能的影响"></a>数据结构对性能的影响</h1><p>我们大概也是举个例子：</p>
<p>ArrayList和LinkedList的大致区别： </p>
<ul>
<li>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 -对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 </li>
<li>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 </li>
</ul>
<p>这里引入另外一个查看方法执行时间的工作，system trace.</p>
<p><img src="http://7xl98n.com1.z0.glb.clouddn.com/systemtrace.gif" alt></p>
<p>对于想检测的函数方法，我们可以在前后加上代码，然后在抓trace的时候，需要中选应用对应的包名，才可以看到对应的标签。</p>
<p><img src="http://7xl98n.com1.z0.glb.clouddn.com/%E5%9B%BE%E7%89%8723.png" alt></p>
<p>即上图中的 Trace.begingSection()和 Trace.endSection()</p>
<p><img src="http://7xl98n.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170725112812.png" alt></p>
<h1 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h1><p>本章主要介绍在算法优化上两个我们可以使用作为分析的辅助工具 TraceView和systemtrace。<br>具体的算法优化方法有批处理，缓存、多线程、数据结构优化，这边只是举了视频中的例子。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2016/07/01/android performance part1/">Android performance par1: Render</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-07-01
        </span><span class="post-category">
            <a href="/categories/ANDROID/">ANDROID</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这几篇文章是根据谷歌出的Android性能的专题视频的总结以及实验的笔记，这个视频主题从Render渲染、compute算法、memory算法、battery电池这几个方面来讲述如何对Android应用进行性能上的优化。主要是介绍了一些检测的工具，和优化的策略。</p>
<p>#Render#</p>
<p>CPU负责把UI组件计算成Polygons，Texture纹理，然后交给GPU进行栅格化渲染。<br>每次从CPU转移到GPU是一件很麻烦的事情，OpenGL ES可以把那些需要渲染的纹理Hold在GPU Memory里面，在下次需要渲染的时候直接进行操作<br>在Android里面那些由主题所提供的资源，例如Bitmaps，Drawables都是一起打包到统一的Texture纹理当中，然后再传递到 GPU里面<br>当然随着UI组件的越来越丰富，有了更多演变的形态。例如显示图 片的时候，需要先经过CPU的计算加载到内存中，然后传递给GPU进行渲染。文字的显示更加复杂，需要先经过CPU换算成纹理，然后再交给GPU进行渲 染，回到CPU绘制单个字符之后，再重新引用经过GPU渲染的内容。动画则是一个更加复杂的操作流程。<br><img src="http://7xl98n.com1.z0.glb.clouddn.com/%E5%9B%BE%E7%89%871.png" alt></p>
<h2 id="卡顿原因"><a href="#卡顿原因" class="headerlink" title="卡顿原因"></a>卡顿原因</h2><p>手机的刷新频率为60fps,如果当前需要处理的事情太多了，以至于无法再16ms内完成frame的刷新，就造成了丢帧，在视觉上，就给用户卡顿的感觉。如果此时用户正在进行一些交互，比如滑动屏幕、输入文字等，这种卡顿就会尤为明显。<br><img src="http://7xl98n.com1.z0.glb.clouddn.com/%E5%9B%BE%E7%89%872.png" alt></p>
<p>另外，虚拟机在执行GC垃圾回收操作时所有线程（包括UI线程）都需要暂停，当GC垃圾回收完成之后所有线程才能够继续执行。所以如果此时有大量的GC操作，也会引起卡顿问题。</p>
<h2 id="UI性能优化策略"><a href="#UI性能优化策略" class="headerlink" title="UI性能优化策略"></a>UI性能优化策略</h2><ol>
<li><p>CPU side: 不必要的layout和invalidations。过多的view hierarchy和不必要的重绘导致CPU过度的刷新displaylist和相关的GPU资源</p>
</li>
<li><p>GPU side: overdraw。</p>
</li>
</ol>
<p><img src="http://7xl98n.com1.z0.glb.clouddn.com/%E5%9B%BE%E7%89%873.png" alt></p>
<h3 id="Overdraw"><a href="#Overdraw" class="headerlink" title="Overdraw"></a>Overdraw</h3><p>Overdraw(过度绘制)描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次<br>在多层次重叠的UI结构里面，如果不可见的UI也在做绘制的操作，会导致某些像素区域被绘制了多次。这样就会浪费大量的CPU以及GPU资源。</p>
<p><img src="http://7xl98n.com1.z0.glb.clouddn.com/%E5%9B%BE%E7%89%874.png" alt></p>
<p>overdraw检测：在手机的开发者选项中，选择’调试GPU过度绘制’-&gt;’显示过度绘制区域’</p>
<p>我们的目标是，减少红色区域的面积大小</p>
<p><img src="http://7xl98n.com1.z0.glb.clouddn.com/%E5%9B%BE%E7%89%875.png?imageView2/1/w/200/h/348/q/75" alt></p>
<p><img src="http://7xl98n.com1.z0.glb.clouddn.com/%E5%9B%BE%E7%89%876.png" alt></p>
<p>示例一：</p>
<p>去除background</p>
<p><img src="http://7xl98n.com1.z0.glb.clouddn.com/%E5%9B%BE%E7%89%877.png?imageView2/1/w/200/h/348/q/75" alt></p>
<p>对应代码，查看是否可以减少红色区域的面积</p>
<pre><code>&lt;FrameLayout
        android:layout_width=&quot;fill_parent&quot;
        android:layout_height=&quot;fill_parent&quot;
        android:background=&quot;@color/white&quot;&gt;

        &lt;include layout=&quot;@layout/main_content&quot; /&gt;

        &lt;com.zowee.lib.widget.HeaderLayout
            xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
            android:id=&quot;@+id/header_hl&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;@dimen/title_height&quot;
            android:background=&quot;@color/main_title_bg&quot;
            app:hlNavigationIcon=&quot;@drawable/main_menu_btn&quot;
            app:hlNavigationMinWidth=&quot;@dimen/title_height&quot;
            app:hlNavigationScaleType=&quot;centerInside&quot;
            app:hlSupportTranslucentStatus=&quot;true&quot;
            app:hlTitleText=&quot;@string/main_title&quot; /&gt;
    &lt;/FrameLayout&gt;</code></pre><p>发现代码中可能之前无意加的 ‘android:background=”@color/white”‘,把背景去掉试试</p>
<p><img src="http://7xl98n.com1.z0.glb.clouddn.com/%E5%9B%BE%E7%89%878.png?imageView2/1/w/200/h/348/q/75" alt></p>
<p>果然红色区域去掉了<del>~</del></p>
<p>官方示例:</p>
<pre><code>protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    // Don&apos;t draw anything until all the Asynctasks are done and all the DroidCards are ready.
    if (mDroids.length &gt; 0 &amp;&amp; mDroidCards.size() == mDroids.length) {
        // Loop over all the droids, except the last one.
        int i;

        for (i = 0; i &lt; mDroidCards.size()-1; i++) {
            // Each card is laid out a little to the right of the previous one.
            mCardLeft = i * mCardSpacing;
            // Save the canvas state
            canvas.save();

            // Restrict the drawing area to what is visible
            canvas.clipRect(mCardLeft, 0, mCardLeft+mCardSpacing, mDroidCards.get(i).getHeight());

            drawDroidCard(canvas, mDroidCards.get(i), mCardLeft, 0);

            // Restore canvas to non-clipping state
            canvas.restore();
        }
        // Draw the final card without clipping
        drawDroidCard(canvas, mDroidCards.get(i), mCardLeft + mCardSpacing, 0);
    }
    // Invalidate the whole view. Doing this calls onDraw() if the view is visible.
    invalidate();
}</code></pre><p>canvas.clipRect(mCardLeft, 0, mCardLeft+mCardSpacing, mDroidCards.get(i).getHeight()); 指明画布的可见区域。对比clipRect后，避免过度重绘的效果</p>
<p><img src="http://7xl98n.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20170710115604.png" alt></p>
<h3 id="Hierachy"><a href="#Hierachy" class="headerlink" title="Hierachy"></a>Hierachy</h3><p>Hierachy用于查看界面的层级结构。</p>
<p><img src="http://7xl98n.com1.z0.glb.clouddn.com/hierarchy.gif" alt></p>
<p>尽量减少界面的层级结构，尽量使用include、merge、ViewStub标签，尽量不存在冗余嵌套及过于复杂布局，尽量使用GONE替换INVISIBLE，使用weight后尽量将width和heigh设置为0dp减少运算，Item存在非常复杂的嵌套时考虑使用自定义Item View来取代，减少measure与layout次数等。自定义View等绘图与布局优化；尽量避免在draw、measure、layout中做过于耗时及耗内存操作，尤其是draw方法中，尽量减少draw、measure、layout等执行次数。</p>
<h3 id="Lint"><a href="#Lint" class="headerlink" title="Lint"></a>Lint</h3><p>代码区点击右键-&gt;Analyze-&gt;Inspect Code–&gt;界面选择你要检测的模块-&gt;点击确认开始检测</p>
<p><img src="http://7xl98n.com1.z0.glb.clouddn.com/%E5%9B%BE%E7%89%8716.png" alt></p>
<p>检测结果：</p>
<p><img src="http://7xl98n.com1.z0.glb.clouddn.com/lint-1.png" alt></p>
<h2 id="UI性能分析解决总结"><a href="#UI性能分析解决总结" class="headerlink" title="UI性能分析解决总结"></a>UI性能分析解决总结</h2><ul>
<li>布局优化；尽量使用include、merge、ViewStub标签，尽量不存在冗余嵌套及过于复杂布局（譬如10层就会直接异常），尽量使用GONE替换INVISIBLE，使用weight后尽量将width和heigh设置为0dp减少运算，Item存在非常复杂的嵌套时考虑使用自定义Item View来取代，减少measure与layout次数等。</li>
<li>列表及Adapter优化；尽量复用getView方法中的相关View，不重复获取实例导致卡顿，列表尽量在滑动过程中不进行UI元素刷新等。</li>
<li>背景和图片等内存分配优化；尽量减少不必要的背景设置，图片尽量压缩处理显示，尽量避免频繁内存抖动等问题出现。</li>
<li>自定义View等绘图与布局优化；尽量避免在draw、measure、layout中做过于耗时及耗内存操作，尤其是draw方法中，尽量减少draw、measure、layout等执行次数。</li>
<li>canvas.clipRect 限制draw的可见区域</li>
</ul>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2016/06/25/Proguard error/">使用第三方库后proguard报错问题</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-06-25
        </span><span class="post-category">
            <a href="/categories/android/">android</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h1 id="添加jar包或者aar库"><a href="#添加jar包或者aar库" class="headerlink" title="添加jar包或者aar库"></a>添加jar包或者aar库</h1><p>在mk源码编译下，当aar做普通的jar包lib库用就可以了<br>Android.mk</p>
<pre><code>LOCAL_PROGUARD_FLAG_FILES := proguard.flags
LOCAL_STATIC_JAVA_LIBRARIES := \
    android-ex-variablespeed \
    lmlibrary

.......

include $(CLEAR_VARS)
LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES := \
    lmlibrary:libs/lmlibrary-release.aar

include $(BUILD_MULTI_PREBUILT)</code></pre><p>由于编译后会进行混淆，所以一般如果有proguard报错，需要在proguard文件中添加如下内容：</p>
<pre><code>-libraryjars libs/lmlibrary-release.aar
-keep class  com.alibaba.fastjson.** { *;}
-dontwarn  com.alibaba.fastjson.**</code></pre>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2016/04/23/Simple Android Server/">简易 Android 服务器</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-04-23
        </span><span class="post-category">
            <a href="/categories/android-server/">android-server</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h1 id="在Android上部署一个简单的服务器"><a href="#在Android上部署一个简单的服务器" class="headerlink" title="在Android上部署一个简单的服务器"></a>在Android上部署一个简单的服务器</h1><p>主要的应用场景：在android端建一个简单的服务器，这样比如在同一个局域网的其他设备，可以通过浏览器访问“ip地址+端口”，访问android服务器端的一些资源。就好像我们经常见，通过浏览器设置wifi配置那样。</p>
<p>因为业务需求相对简单，而且给我们的研发投入就是，一个人，一周左右的时间。所以，我看到jetty什么的有点头大，就没有用一些商业的现有的android web 服务器，倒是apache的httpcore.jar包解决了我大部分的问题，但是这个在4.0之后都被弃用了。所以需要的，请下载对应的jar 包，下载地址<a href="http://www.apache.org/dist/httpcomponents/httpcore/source/" target="_blank" rel="noopener">httpcomponents/httpcore</a></p>
<h1 id="搭建web-server"><a href="#搭建web-server" class="headerlink" title="搭建web server"></a>搭建web server</h1><p>首先，我们主要参考一篇博文<a href="http://blog.csdn.net/jiangwei0910410003/article/details/27861135" target="_blank" rel="noopener">Android中如何搭建一个WebServer</a>。</p>
<p>大部分的服务器代码就是参考他的几个基本模块，可以让你快速的搭建一个Android 端的web服务器。主要的核心代码就是，在Android建一个<code>ServerSocket</code>，然后用httpcore中的一些类来负责处理<code>serversocket.accept()</code>每次接收的socket；分析请求，返回响应。</p>
<h1 id="动态网页"><a href="#动态网页" class="headerlink" title="动态网页"></a>动态网页</h1><p>大部分的服务器代码如所链接的博文那样，基本上，另外一个连接的设备，通过浏览器访问对应地址，就可以收到回复。但是，在我的简单需求里面，还有一点点小复杂的东西：获取android服务器端的某些信息，需要写到发送给客户端的html代码里面。</p>
<p>基本思路是：将写号的html 模板（大部分是html代码，具体数值方面，用<code>$valuename</code>来替代)，这样，在response中写入反馈的时候，可以先将template模板中的变量进行过滤，替换为对应的数值和html标签，最终生成一份html代码，在反馈给客户端。</p>
<p>这就是一个伪动态网页了</p>
<h1 id="获取post请求中的参数"><a href="#获取post请求中的参数" class="headerlink" title="获取post请求中的参数"></a>获取post请求中的参数</h1><p>另外博文中没有提到的一个很重要的功能，就是获取网页代码中，提交的form表单数据。原先我以为会很简单，比如在request中用个类似于<code>getParameter（XXXX）</code>不就搞定了么。可事实上，这样，你得到的永远都是<code>null</code>。</p>
<p>后来找了很久，发现了这个<a href="http://stackoverflow.com/questions/7199969/apache-httpcore-simple-server-to-echo-received-post-data" target="_blank" rel="noopener">echo-received-post-data</a>。</p>
<p>所以获取html 表单数据类似于需要这样：</p>
<h2 id="html表单代码"><a href="#html表单代码" class="headerlink" title="html表单代码"></a>html表单代码</h2><p>例如，我们有一个如下的表单需要提交，而且，一般有密码的表单都是用POST请求，因为我们可不想浏览器的地址上赫赫然地写着passwork=abc;</p>
<pre><code>&lt;form method=&quot;POST&quot; action=&quot;/submit&quot; name=&quot;forms&quot; enctype=&quot;text/plain&quot; onsubmit=&quot;return toVaild()&quot;&gt;
Network SSID: 
&lt;input type=&quot;text&quot; name=&quot;SSID&quot; id=&quot;SSID&quot; value=&quot;AndroidAp&quot; /&gt;
&lt;br /&gt;
Security: 
&lt;select name=&quot;Security&quot;&gt; 
&lt;option value=&quot;0&quot;&gt;None&lt;/option&gt; 
&lt;option value=&quot;1&quot;&gt;WPA PSK&lt;/option&gt; 
&lt;option value=&quot;2&quot;  selected=&quot;selected&quot;&gt;WPA2 PSK&lt;/option&gt; 
&lt;/select&gt; 
&lt;br /&gt;
Password: 
&lt;span id=box&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;  id=&quot;password&quot; value=&quot;&quot; /&gt;&lt;/span&gt; &lt;span id=click&gt;&lt;a href=&quot;javascript:showps()&quot;&gt;Show password&lt;/a&gt;&lt;/span&gt;
&lt;br /&gt;
The password must have at least 8 characters

&lt;br /&gt;
&lt;input type=&quot;submit&quot; id=&quot;submit&quot; value=&quot;Submit&quot; /&gt;

&lt;/form&gt;</code></pre><h2 id="服务器端handler代码"><a href="#服务器端handler代码" class="headerlink" title="服务器端handler代码"></a>服务器端handler代码</h2><p>根据验证发现：当表单采用post方式提交数据后，<code>HttpRequestHandler</code>的handler方法参数中的request，实际上会变成一个<code>BasicHttpEntityEnclosingRequest</code>实例，而普通的get请求request则是<code>BasicHttpRequest</code>实例。</p>
<p>服务器获取post请求中的数据相关代码：</p>
<pre><code>static class WebServiceHandler implements HttpRequestHandler {
        private PageEntity mPageEntity;

        public WebServiceHandler(Context context) {
            mPageEntity = new PageEntity(context);
        }

        @Override
        public void handle(HttpRequest request, HttpResponse response,
                HttpContext context) throws HttpException, IOException {

            Log.i(TAG, &quot;WebServiceHandler handle request=&quot; + request);

            String method = request.getRequestLine().getMethod()
                    .toUpperCase(Locale.ENGLISH);
            String target = request.getRequestLine().getUri();

            Log.i(TAG, &quot;WebServiceHandler handle method=&quot; + method);

            Log.i(TAG, &quot;WebServiceHandler handle target=&quot; + target);

            Log.i(TAG, &quot;WebServiceHandler handle request.getParams()=&quot;
                    + request.getParams()); //放心，我们要的parameter不在这个里面，never

            if(request instanceof BasicHttpEntityEnclosingRequest){
                HttpEntity entity = ((BasicHttpEntityEnclosingRequest) request).getEntity();

                byte[] data;
                if (entity == null) {
                    data = new byte [0];
                } else {
                    data = EntityUtils.toByteArray(entity);
                }

                Log.i(TAG,new String(data));//把这段话答应出来，里面就是post表单中的键值对。
            }
            response.setStatusCode(HttpStatus.SC_OK);
            response.setEntity(mPageEntity.getPage(&quot;index.html&quot;));
        }
}</code></pre><p>我们运行之后，果然在log中打印出来post表单中的键值对<code>SSID=AndroidAp&amp;Security=2&amp;password=ttyyyyyyyyy</code>;</p>
<p>这样完成服务器和网页客户端的数据互通。其他的问题，就是一个搬运和时间的问题了。</p>
<h1 id="获取get请求中的参数"><a href="#获取get请求中的参数" class="headerlink" title="获取get请求中的参数"></a>获取get请求中的参数</h1><p>另外提一下，get请求，因为参数直接写在uri中，我们可以通过</p>
<pre><code>String method = request.getRequestLine().getMethod()
        .toUpperCase(Locale.ENGLISH);
String target = request.getRequestLine().getUri();</code></pre><p>直接在target中得到<code>target=/submit?SSID=AndroidAp&amp;Security=2&amp;password=ffffffgggfffff</code><br>所需要的参数。</p>
<h1 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h1><p>基本这个服务器可以完成图片、css、js、文件等传送，看看首页效果：</p>
<p><img src="http://7xl98n.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9B%BE20160625154803.png" alt></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>因为整体的业务逻辑和需求比较简单，我们估计只需要一个信息页面，然后这个页面可以提交数据，最多再加一两个正确和错误的提示页面。所以这个简单web server就是这样。如果要是复杂的，当然在看资料的是，也发现有人用KSWEB，或者android i-jetty把android 设备作为服务器，运行wordpress等。感觉也可以很强大，不过我下了都是要收费的。我这个小project就算了。还是回到原始，解决问题，最关键。O(∩_∩)O</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2016/03/10/c qrcode lib/">MTK feature phone上生成二维码</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-03-10
        </span><span class="post-category">
            <a href="/categories/QRCODE/">QRCODE</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h1 id="添加LibQREncode"><a href="#添加LibQREncode" class="headerlink" title="添加LibQREncode"></a>添加LibQREncode</h1><p>首先呢，我们在github上可以搜到很多LibQREncode相关的项目，LibQREncode使用C语言编写的二维码编码库 github项目地址：<a href="https://github.com/fukuchi/libqrencode" target="_blank" rel="noopener">libqrencode</a></p>
<p>然后我还不小心找到一个QRCODE 生成器的c++代码项目<br><a href="https://github.com/thomasdic2000/QRGenerator/" target="_blank" rel="noopener">QRGenerator</a></p>
<p>那么我接下来的工作就比较简单啦，就将这个C++的二维码生成器移植到feature phone平台上，稍作改良。</p>
<h1 id="生成二维码bmp图片"><a href="#生成二维码bmp图片" class="headerlink" title="生成二维码bmp图片"></a>生成二维码bmp图片</h1><p>根据QRGenerator可以很快改造一下，调用libqrencode库生成二维码bmp图片。代码如下：</p>
<p>bitmap图片编码的一些头文件定义：</p>
<pre><code>#define OUT_FILE_PIXEL_PRESCALER        4
#define PIXEL_COLOR_R                0
#define PIXEL_COLOR_G                0
#define PIXEL_COLOR_B                0
//rgb 0 0 0,代表 黑色
#define BI_RGB                        0L
#pragma pack(push, 1)

typedef struct    
{
    U16    bfType;
    U32    bfSize;
    U16    bfReserved1;
    U16    bfReserved2;
    U32    bfOffBits;
} BITMAPFILEHEADER;

typedef struct 
{
    U32       biSize;
    S32       biWidth;
    S32       biHeight;
    U16       biPlanes;
    U16       biBitCount;
    U32       biCompression;
    U32       biSizeImage;
    S32       biXPelsPerMeter;
    S32       biYPelsPerMeter;
    U32       biClrUsed;
    U32       biClrImportant;
} BITMAPINFOHEADER;

typedef struct
{
    BITMAPFILEHEADER kFileHeader;
    BITMAPINFOHEADER kInfoHeader;
    unsigned char g_rgb_data[100000];
} BITMAPDATA;
#pragma pack(pop)</code></pre><p>实现二维码编码具体代码：<br>    BITMAPDATA bitmapData;//定义一个全局变量，用户存放编码图片信息</p>
<pre><code>// ox要显示的图片的x坐标，Y坐标
// resize_w 调整图片大小
// szSourceString 要转换为二维码的字符串，比如网址啊之类的
int mmi_getQRcode(S32 ox,S32 oy,S32 resize_w, char* szSourceString){
    //char* szSourceString = QRCODE_TEXT;
    unsigned int unWidth,x,y,l,n,unWidthAdjusted,unDataBytes;
    unsigned char* pRGBData,*pSourceData,*pDestData;
    QRcode*  pQRC;
    S32 fd;
    S32 fs_ret;
    U32 nLen;
    S32 w,h,rec_x,rec_y,rec_w;

    S32 resize_h=resize_w;

    pQRC = QRcode_encodeString(szSourceString,0,QR_ECLEVEL_H,QR_MODE_8,1);
    //调用lib库中的函数，获取二维码编码信息。然后接下来的工作都是将获取的这个二维码编码信息转换为图片
    unWidth = pQRC-&gt;width;
    kal_prompt_trace(MOD_MMI,&quot;%d unWidth --linlian .\n&quot;,unWidth);
    unWidthAdjusted = unWidth * OUT_FILE_PIXEL_PRESCALER * 3;
    kal_prompt_trace(MOD_MMI,&quot;%d unWidthAdjusted --linlian .\n&quot;,unWidthAdjusted);
    if (unWidthAdjusted % 4)
        unWidthAdjusted = (unWidthAdjusted / 4 + 1) * 4;

    unDataBytes = unWidthAdjusted * unWidth * OUT_FILE_PIXEL_PRESCALER;

    kal_prompt_trace(MOD_MMI,&quot;%d unDataBytes --linlian .\n&quot;,unDataBytes);

    if (unDataBytes &gt; sizeof(bitmapData.g_rgb_data))
    {
        kal_prompt_trace(MOD_MMI,&quot;%d unDataBytes out of memory --linlian .\n&quot;,unDataBytes);
        return 0; // out of memory
    }
    pRGBData = bitmapData.g_rgb_data;

    memset(pRGBData, 0xff, unDataBytes);//将所有的点设置为0XFF，则为白色
    bitmapData.kFileHeader.bfType = 0x4d42;  // &quot;BM&quot;
    bitmapData.kFileHeader.bfSize =    sizeof(BITMAPFILEHEADER) +
                            sizeof(BITMAPINFOHEADER) +
                            unDataBytes;
    bitmapData.kFileHeader.bfReserved1 = 0;
    bitmapData.kFileHeader.bfReserved2 = 0;
    bitmapData.kFileHeader.bfOffBits =    sizeof(BITMAPFILEHEADER) +
                            sizeof(BITMAPINFOHEADER);
    bitmapData.kInfoHeader.biSize = sizeof(BITMAPINFOHEADER);
    bitmapData.kInfoHeader.biWidth = unWidth * OUT_FILE_PIXEL_PRESCALER;
    bitmapData.kInfoHeader.biHeight = ((int)unWidth * OUT_FILE_PIXEL_PRESCALER);
    bitmapData.kInfoHeader.biPlanes = 1;
    bitmapData.kInfoHeader.biBitCount = 24;
    bitmapData.kInfoHeader.biCompression = BI_RGB;
    bitmapData.kInfoHeader.biSizeImage = 0;
    bitmapData.kInfoHeader.biXPelsPerMeter = 0;
    bitmapData.kInfoHeader.biYPelsPerMeter = 0;
    bitmapData.kInfoHeader.biClrUsed = 0;
    bitmapData.kInfoHeader.biClrImportant = 0;
    pSourceData = pQRC-&gt;data;
    qijiReverseData(pSourceData,unWidth);//linlian@2016.03.04 reverse qrcode image vertically
    for(y = 0; y &lt; unWidth; y++)
    {
        pDestData = pRGBData + unWidthAdjusted * y * OUT_FILE_PIXEL_PRESCALER;
        for(x = 0; x &lt; unWidth; x++)
            {
            if (*pSourceData &amp; 1)//在pSourceData数组中值为1的点，将其颜色设置为BGR 000，则对应点变为黑色
                {
                for(l = 0; l &lt; OUT_FILE_PIXEL_PRESCALER; l++)
                    {
                    for(n = 0; n &lt; OUT_FILE_PIXEL_PRESCALER; n++)
                        {
                        *(pDestData +        n * 3 + unWidthAdjusted * l) =    PIXEL_COLOR_B;
                        *(pDestData + 1 +    n * 3 + unWidthAdjusted * l) =    PIXEL_COLOR_G;
                        *(pDestData + 2 +    n * 3 + unWidthAdjusted * l) =    PIXEL_COLOR_R;
                        }
                    }
                }
            pDestData += 3 * OUT_FILE_PIXEL_PRESCALER;
            pSourceData++;
        }
    }
    //前面这段代码的意思是，初始化好bmp图片文件的头部。
    //并且在后面追加每个点的颜色定义。最后我们获取了一系列黑白点阵


    //OslMfree(pRGBData);
    nLen = sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFOHEADER)+sizeof(unsigned char)*unDataBytes;
    gdi_image_get_dimension_mem(GDI_IMAGE_TYPE_BMP,(U8*)&amp;bitmapData,nLen,&amp;w,&amp;h);
    kal_prompt_trace(MOD_MMI,&quot; %d w --linlian .\n&quot;,w);
    kal_prompt_trace(MOD_MMI,&quot; %d h --linlian .\n&quot;,h);

    img_width =w;
    img_height=h;

    if(w &lt; resize_w || resize_w==0){ //can&apos;t be larger than original width
        resize_w = w;
        resize_h = h;
    }
    if(resize_w&gt;100){
        resize_w =100;
        resize_h =100;
    }
    if(ox&lt;=0||oy&lt;=0){
        ox=(UI_device_width-resize_w)/2;
        oy=(UI_device_height-resize_h)/2+10;
    }
    kal_prompt_trace(MOD_MMI,&quot; %d resize_w --linlian .\n&quot;,resize_w);
    kal_prompt_trace(MOD_MMI,&quot; %d resize_h--linlian .\n&quot;,resize_h);
    //gdi_image_draw_mem(ox,oy,(U8*)&amp;bitmapData,GDI_IMAGE_TYPE_BMP,nLen);

    rec_x = ox-2;
    rec_y = oy-2;
    rec_w = resize_w +4;
    gdi_draw_solid_rect(rec_x,rec_y,rec_x+rec_w,rec_y+rec_w,GDI_COLOR_WHITE);
    gdi_image_draw_resized_mem(ox,oy,resize_w,resize_h,(U8*)&amp;bitmapData,GDI_IMAGE_TYPE_BMP,nLen);

    preWidth = resize_w;
    QRcode_free(pQRC);
    return 1;
}</code></pre><p>这边要说明一下，在pc平台上，将<code>bitmapData.kInfoHeader.biHeight = -((int)unWidth * OUT_FILE_PIXEL_PRESCALER);</code> 也就是biHeight设置为负值的话，可以实现图片的垂直翻转，但是在feature phone上，如果biHeight直接设置为负值，那么图片将不被识别，所以，我们只能将biHeight设置为<code>+((int)unWidth * OUT_FILE_PIXEL_PRESCALER)</code>。因此，在原始的0101数据开始被rgb化的时候，我们先将这串数据组成一个二维正方形数组，并进行以中间高度为中心的上下翻转。即<code>qijiReverseData(pSourceData,unWidth);</code>。对应的代码为</p>
<pre><code>// vertical reverse image 
void qijiReverseData(unsigned char* data, unsigned int unWidth){
    unsigned int i,j;
    unsigned char temp;
    for( i=0 ;i&lt;(unWidth/2);i++){
        for(j=0;j&lt;unWidth;j++){
            temp = data[j+i*unWidth];
            data[j+i*unWidth] = data[(unWidth-1-i)*unWidth+j];
            data[(unWidth-1-i)*unWidth+j]=temp;
        }
    }
}</code></pre><h1 id="平台适配调整"><a href="#平台适配调整" class="headerlink" title="平台适配调整"></a>平台适配调整</h1><p>基本上qrcode lib库的代码在feature phone的模拟器上运行时没有问题的，但是在实际的机子上，需要调整一些内存分配等方法，进行平台适配。例如：</p>
<ul>
<li>data = (unsigned char <em>)*</em>malloc<strong>(bstream-&gt;length + arg-&gt;length);<br>需要改为<br>data = (unsigned char *)</strong>OslMalloc**(bstream-&gt;length + arg-&gt;length);</li>
<li><strong>free</strong>(bstream-&gt;data); –&gt; <strong>OslMfree</strong>(bstream-&gt;data);</li>
<li>raw-&gt;rsblock = (RSblock <em>)<strong>calloc</strong>(raw-&gt;blocks, sizeof(RSblock));改为    raw-&gt;rsblock = (RSblock <em>)*</em>OslMalloc**((raw-&gt;blocks)</em>(sizeof(RSblock)));memset(raw-&gt;rsblock, 0x00, (raw-&gt;blocks)*(sizeof(RSblock)));</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>有时候我们都不知道自己是怎么完成这一步步的瞎子摸象。例如我突然想不起来，曾经写过一个给校准树写DLL的经历，我只记得接到任务的时候，只有“懵逼”来形容，什么事校准树，什么事DLL，特么我是写android的，C是什么鬼，我只在大学学过C++。然后，我在万用的路上越走越远。也许有圣人相助，反正每个感觉完不成的任务，最后也都完成了，再见了feature phone<del>~</del></p>

        </div></article>
      <nav class="pagination"><a class="prev" href="/page/2/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">上一页</span>
      </a>
    <a class="next" href="/page/4/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></section></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
        <a href="https://github.com/ahonn" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2015 - 2019<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">lynn8570</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
